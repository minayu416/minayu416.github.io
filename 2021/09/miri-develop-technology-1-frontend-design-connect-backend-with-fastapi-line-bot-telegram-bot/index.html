<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="https://minayu.site/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" as="image" href="/static/img/blog-cover-image.jpg"/><link rel="preload" as="image" href="https://minayu0416.files.wordpress.com/2021/09/screen-shot-2021-09-06-at-4.55.08-pm.png"/><link rel="preload" as="image" href="/static/img/logo.jpg"/><link rel="stylesheet" href="https://minayu.site/_next/static/css/48a85a1880fd302d.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="https://minayu.site/_next/static/chunks/webpack-7335b41bc6ef882c.js"/><script src="https://minayu.site/_next/static/chunks/fd9d1056-62aaf4b921c84028.js" async=""></script><script src="https://minayu.site/_next/static/chunks/23-020bd7ae6b960732.js" async=""></script><script src="https://minayu.site/_next/static/chunks/main-app-8ae949d2ebb17dd8.js" async=""></script><script src="https://minayu.site/_next/static/chunks/app/layout-e39bf6f0e9a90cbf.js" async=""></script><script src="https://minayu.site/_next/static/chunks/870fdd6f-d8d8a996639eb86b.js" async=""></script><script src="https://minayu.site/_next/static/chunks/168-06c8f4fac5ec5c0f.js" async=""></script><script src="https://minayu.site/_next/static/chunks/619-4671ee34442d690f.js" async=""></script><script src="https://minayu.site/_next/static/chunks/app/%5B...routes%5D/page-ab50a535e409addd.js" async=""></script><link rel="preload" href="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" as="script"/><link rel="preload" href="https://www.googletagmanager.com/gtag/js?id=G-EETGWC7GNV" as="script"/><title>[產品使用技術][Python] Miri的前端與後端接口、整體程式架構介紹 | FastApi x Line Bot x Telegram Bot | 開發概念系列(1) - 月水瓶 @Mina 的人生實驗室</title><meta name="description" content="在2021年2月離職後，我用了半年的時間用Python開發自己的占卜機器人作品，在這版本的開發有很大幅度的變動，我將原本的Flask框架改為FastApi，由原本只有Line Bot平台，新增Telegram的平台，無論是程式開發還是這篇文章都是自己綜合實力、努力、堅強跟嘗試的心血，它帶給我很多心靈上跟實力上的進步，現在我就來分享這半年實作技術方面的點點滴滴。"/><meta name="application-name" content="月水瓶 @Mina 的人生實驗室"/><meta name="author" content="minayu416"/><link rel="author" href="https://minayu.site"/><meta name="author" content="@Mina Influence"/><meta name="generator" content="Next.js 14.2.5"/><meta name="keywords" content="python,fastapi,line bot,telegram bot,heroku"/><meta name="referrer" content="origin-when-cross-origin"/><meta name="creator" content="minayu416"/><meta name="publisher" content="minayu416"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://minayu.site/2021/09/miri-develop-technology-1-frontend-design-connect-backend-with-fastapi-line-bot-telegram-bot/"/><link rel="alternate" hrefLang="zh-TW" href="https://minayu.site/2021/09/miri-develop-technology-1-frontend-design-connect-backend-with-fastapi-line-bot-telegram-bot/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="[產品使用技術][Python] Miri的前端與後端接口、整體程式架構介紹 | FastApi x Line Bot x Telegram Bot | 開發概念系列(1)"/><meta property="og:description" content="在2021年2月離職後，我用了半年的時間用Python開發自己的占卜機器人作品，在這版本的開發有很大幅度的變動，我將原本的Flask框架改為FastApi，由原本只有Line Bot平台，新增Telegram的平台，無論是程式開發還是這篇文章都是自己綜合實力、努力、堅強跟嘗試的心血，它帶給我很多心靈上跟實力上的進步，現在我就來分享這半年實作技術方面的點點滴滴。"/><meta property="og:url" content="https://minayu.site/2021/09/miri-develop-technology-1-frontend-design-connect-backend-with-fastapi-line-bot-telegram-bot/"/><meta property="og:site_name" content="月水瓶 @Mina 的人生實驗室"/><meta property="og:locale" content="zh-TW"/><meta property="og:image" content="https://minayu0416.files.wordpress.com/2021/09//screen-shot-2021-09-06-at-4.55.08-pm.png"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2021-09-06T11:32:09.000Z"/><meta property="article:author" content="Mina Yu"/><meta name="twitter:card" content="summary"/><meta name="twitter:site:id" content="@MingJungYU"/><meta name="twitter:creator" content="@MingJungYU"/><meta name="twitter:title" content="[產品使用技術][Python] Miri的前端與後端接口、整體程式架構介紹 | FastApi x Line Bot x Telegram Bot | 開發概念系列(1)"/><meta name="twitter:description" content="在2021年2月離職後，我用了半年的時間用Python開發自己的占卜機器人作品，在這版本的開發有很大幅度的變動，我將原本的Flask框架改為FastApi，由原本只有Line Bot平台，新增Telegram的平台，無論是程式開發還是這篇文章都是自己綜合實力、努力、堅強跟嘗試的心血，它帶給我很多心靈上跟實力上的進步，現在我就來分享這半年實作技術方面的點點滴滴。"/><meta name="twitter:image" content="https://minayu0416.files.wordpress.com/2021/09//screen-shot-2021-09-06-at-4.55.08-pm.png"/><meta name="twitter:image:alt" content="@Mina Influence Image"/><link rel="shortcut icon" href="/static/img/favicon.jpg"/><link rel="icon" href="/static/img/favicon.jpg"/><link rel="apple-touch-icon" href="/static/img/favicon.jpg"/><meta name="next-size-adjust"/><script src="https://minayu.site/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body><header><div class="max-auto"><div class="mx-auto flex flex-wrap border-b border-solid"><div class="lg:w-1/2 w-full lg: h-full object-cover object-center bg-cover"><div class="w-full h-full"><div class="relative overflow-hidden"><img class="object-cover w-full brightness-75 h-[20rem]` md:h-[25rem]" src="/static/img/blog-cover-image.jpg" alt="Blog Cover Image"/><div><nav><div class="absolute top-0 left-0 px-2 py-2 z-10 header-navbar"><div class="px-6"><div class="mx-auto"><div class="flex"><div class="flex space-x-4"><div class="hidden md:flex items-center space-x-1 header-navbar-menu text-white"><a href="/about/" class="py-4 px-3">about</a><a href="/" class="py-4 px-3">home</a><a href="/blog/" class="py-4 px-3">blog</a><a href="/portfolio/" class="py-4 px-3">portfolio</a><a target="_blank" href="/resume/" class="text-xs py-4 px-2 text-yellow-100">Resume</a></div></div><div class="md:hidden flex items-center"><button class="pt-4 px-2"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white" viewBox="0 0 24 24" style="fill:none;stroke:currentColor;stroke-width:2"><path style="stroke-linecap:round;stroke-linejoin:round" d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></div></div><div id="mobile-menu" class="md:hidden absolute w-full rounded header-mobile-menu hidden"><a href="/about/" class="block py-3 px-4">about</a><a href="/" class="block py-3 px-4">home</a><a href="/blog/" class="block py-3 px-4">blog</a><a href="/portfolio/" class="block py-3 px-4">portfolio</a><a target="_blank" href="/resume/" class="text-xs block py-3 px-4 text-yellow-800">Resume</a><div class="block py-3 px-4"><span><a href="/blog" class="py-4 px-2">中文</a> <!-- -->/</span><span><a href="/en/blog" class="py-4 px-2">en</a> </span></div></div></div><div class="absolute top-0 right-0 px-2 py-2 z-10"><div class="px-6"><div class="mx-auto"><div class="flex"><div class="flex space-x-4"><div class="hidden md:flex items-center space-x-1 header-navbar-menu text-white"><a href="/blog" class="py-4 px-2">中文</a><a href="/en/blog" class="py-4 px-2">en</a></div></div></div></div></div></div></nav><div class="absolute px-2 py-2 site-branding h-[25rem]"><div class="site-title"><p><a href="/">@Mina Influence</a></p></div><div class="site-description"><p>Inspire you to have New thinking, Walk out your unique Road.</p></div></div></div></div></div></div><div class="grid justify-items-center lg:w-1/2 w-full lg:h-auto lg:py-6 mt-6 lg:mt-0 hidden md:block"><div class="blog-branding-intro motto-block"><section class="text-gray-500 body-font"><div class="container px-6 mx-auto"><div class="w-full mx-auto text-center"><svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" class="inline-block w-6 h-6 text-gray-400 mb-4" viewBox="0 0 975.036 975.036"><path d="M925.036 57.197h-304c-27.6 0-50 22.4-50 50v304c0 27.601 22.4 50 50 50h145.5c-1.9 79.601-20.4 143.3-55.4 191.2-27.6 37.8-69.399 69.1-125.3 93.8-25.7 11.3-36.8 41.7-24.8 67.101l36 76c11.6 24.399 40.3 35.1 65.1 24.399 66.2-28.6 122.101-64.8 167.7-108.8 55.601-53.7 93.7-114.3 114.3-181.9 20.601-67.6 30.9-159.8 30.9-276.8v-239c0-27.599-22.401-50-50-50zM106.036 913.497c65.4-28.5 121-64.699 166.9-108.6 56.1-53.7 94.4-114.1 115-181.2 20.6-67.1 30.899-159.6 30.899-277.5v-239c0-27.6-22.399-50-50-50h-304c-27.6 0-50 22.4-50 50v304c0 27.601 22.4 50 50 50h145.5c-1.9 79.601-20.4 143.3-55.4 191.2-27.6 37.8-69.4 69.1-125.3 93.8-25.7 11.3-36.8 41.7-24.8 67.101l35.9 75.8c11.601 24.399 40.501 35.2 65.301 24.399z"></path></svg><p class="leading-relaxed">有的時候，你無意間遇到的一些故事，會激發你的靈感，改變你的想法，接下來你會用與之前全然不同的觀念去創造屬於你獨特的故事。</p><span class="inline-block h-1 w-10 rounded bg-pink-500 mt-8 mb-6"></span><h2 class="text-gray-900 font-medium title-font tracking-wider text-lg">Sign @MinaYu.</h2></div></div></section></div></div></div></div></header><section class="text-gray-600 body-font"><div class="container py-12 mx-auto"><div class="flex-wrap"><div class="p-2"><div class="mx-auto flex flex-wrap bg-white"><div class="lg:w-2/3 w-full lg: h-full object-cover object-center bg-cover"><div class="px-4 mb-4"><div class="mb-10 border border-solid py-4"><p class="text-center tracking-widest text-md font-medium post-category font-fondamento">軟體開發 SWD</p><h3 class="text-center tracking-widest text-md font-medium post-category font-fondamento">software-development</h3><p class="font-bold text-center text-gray grid-subtitle text-md font-fondamento px-4 pt-2 pb-2">[產品使用技術][Python] Miri的前端與後端接口、整體程式架構介紹 | FastApi x Line Bot x Telegram Bot | 開發概念系列(1)</p><p class="text-center test-gray italic tracking-wider font-mario">Posted on <!-- -->Sep<!-- --> <!-- -->6<!-- -->, <!-- -->2021</p></div><div class="flex-wrap"><img class="h-full w-full object-cover object-center mb-6 border border-solid" src="https://minayu0416.files.wordpress.com/2021/09/screen-shot-2021-09-06-at-4.55.08-pm.png" alt=""/><article class="prose prose-slate prose-lg md:prose-base max-w-none break-words whitespace-pre-wrap [&amp;_h1]:text-2xl [&amp;_h1]:mb-0 [&amp;_h2]:mb-0 [&amp;_h2]:text-xl [&amp;_p]:mt-2 [&amp;_p]:mb-2 [&amp;_li]:mt-1 [&amp;_li]:mb-1 [&amp;_li]:leading-snug [&amp;_ul]:mt-0 [&amp;_ul]:mb-0 [&amp;_ul]:leading-none"><div><p>由於本人健康問題，再加上這幾天有其他事情比較重要，還有就是一下把開發感想寫完，寫文章的靈感突然全無，所以跟技巧還有概念設計相關的文章就拖到了現在才有靈感撰寫。</p>
<p>再將近一週內心的沈澱後，我想應該可以好好的撰寫本系列的文章了，我應該會分成三到四篇來撰寫。</p>
<p>這篇主要介紹的是 Miri 的前端設計，以及和後端 API 接口的程式設計。</p>
<p><strong><em>整篇文章非常的長，以下為整篇文章的目錄</em></strong></p>
<p>目錄如下：</p>
<ul>
<li>概念: 前端設計</li>
<li>重構: API 及後端整體架構設計</li>
<li>實作: 期望與模擬的後端 API 層架構實作</li>
<li>實作: FastApi (含 Heroku 部署程式碼)</li>
<li>實作: Line Bot
<ul>
<li>事件 Event</li>
<li>訊息型別 Message Type</li>
<li>實作: Api &#x26; handler</li>
<li>選單 Menu</li>
<li>Line Bot 的一些注意細節</li>
</ul>
</li>
<li>實作: Telegram Bot
<ul>
<li>訊息處理者 Handler</li>
<li>Message Type 訊息型別</li>
<li>創建一個 Telegram Bot</li>
<li>實作 Api &#x26; Handler</li>
<li>Telegram Bot 的一些注意細節</li>
<li>選單 Menu</li>
</ul>
</li>
<li>困難克服: 訊息於不同平台的呈現方式</li>
</ul>
<p>那麼就開始吧！</p>
<h1 id="概念-前端設計">概念: 前端設計</h1>
<p>Miri 在之前跟第三版本的規劃中，是沒有要將前端獨立出來開發的計畫，因為本人當初還只是很菜鳥的後端工程師，連後端開發都吃力了，要怎麼去學習前端。所以從 Miri 剛開始出生時，我就是先是打算利用<code>Line Bot Api</code>的功能，讓 Line 代替前端的功能，使我能夠更專注的在開發後端，將 Miri 做成一個 Line 的聊天機器人。</p>
<p>但是，在規劃第三版本時，我希望能夠朝向更國際化的市場前進，說白了一點就是希望能找國外的工作，讓外國的面試官看到這個作品，所以想要新增其他新的 Bot 平台，畢竟 Line 目前還是在東亞洲地區比較興盛，除此之外的地區都不是 Line 的主要地盤，所以若是要開發一個面向英文使用者的平台，就要另外找其他通訊軟體的 Bot 功能。</p>
<p>最一開始我有想過<code>What's App</code> 跟 <code>Facebook 的 Messenger</code>，但經過研究跟實際實作時，我發現要開發起來十分困難，會有些障礙，而且比較難克服。在一個外國朋友的推薦下，後來選擇了<code>Telegram</code>當作第二個可以連接到 Miri 的平台。</p>
<p>仔細看了 <code>Telegram Bot Api</code>後，發現他有和<code>Line Bot Api</code>相似的功能，也許在圖像化或者前端畫面豐富性沒有像 Line 那樣的齊全，但作為 Miri 另外一個連接的 Bot 平台，功能也夠了。</p>
<p>(才怪，我當初可是擔心死了，害怕在 Line 上能呈現的效果，在 Telegram 上到底要怎麼呈現 qq)</p>
<h1 id="重構-後端及-api-架構設計">重構: 後端及 API 架構設計</h1>
<p>有了要接兩個不同前端的平台的邏輯後，後端的程式架構就必須得做一些改變，我們先來看看第二版以前的 Miri 程式架構。</p>
<p><img src="https://minayu0416.files.wordpress.com/2021/09/screen-shot-2021-09-06-at-4.42.38-pm.png" alt=""></p>
<p>在第二版以及之前的架構中，由於本身還只是年幼的後端工程師，再加上所經歷的專案跟產品經驗不多，也沒有單獨設計程式架構的經驗，所以在當時連 Api 是什麼都很吃力理解的狀態下，硬是兜了簡單的架構。(就是隨便做)</p>
<p>從圖中可以看到的是第二版是使用<code>Flask</code>的框架來實作，而由於當初的前端平台只有 Line，所以就把 <code>Flask</code> 跟 <code>Line</code> 的程式碼混在一起。</p>
<p>後端功能上非常簡單，當初並沒有需要紀錄帳號的功能，也沒有像現在這樣需要不同平台，所以基本上 Line 接收進來的訊息，直接丟進<code>NLTK</code>或<code>Jieba</code>切詞後，去功能面簡單撈一下回答就把回覆送回給客戶端。</p>
<p>那麼看一下第三版的程式架構圖</p>
<p><img src="https://minayu0416.files.wordpress.com/2021/09/screen-shot-2021-09-06-at-4.55.08-pm.png" alt=""></p>
<p>比起上一個版本，由於要串接兩個不同的平台，所以在後端 API 中勢必得將不同平台的 API 入口分割開來，如圖中的架構，當然也因為為了相容兩種不同平台而做出的重構，在未來若有規劃想要開發出獨立的前端像是<code>前端網頁</code>或者<code>app mobile行動端</code>都可以相容，而不用再做出這麼大幅度的更動。</p>
<p>再來還有一個很重要的點就是，由於目前是有兩種不同的平台而來的訊息，收到的訊息模式跟型別也會不同，在規劃上會特地多一個 <code>process</code>的步驟，主要是用來處理</p>
<ul>
<li>將收到訊息統一處理為另外一種訊息物件可以不分平台差異傳送到後面的<code>功能層面</code> 取得回覆</li>
<li>將從<code>功能層面</code>取到的回覆傳回指定平台的<code>process</code>處理成可以傳回客戶端的訊息模板/型態</li>
</ul>
<p>這是後端其中一個比較大幅度需要更改的重構部分。</p>
<p>而另外一個部分則是<code>功能層面</code>，因為 Miri 在第三版本確定會往<code>命理跟占卜</code>方向前進，所以比較大的主題功能會落於<code>命理及占卜</code>，把這個部分作為主要功能，而另外一個<code>溝通功能</code>則是保留若未來需要類似<code>聊天/溝通</code>的功能，還可以在這塊規劃的地區做開發。</p>
<p>主要主題是<code>命理跟占卜</code>，所以基本上功能面就是依照這個主題去展開程式架構，然後由每個功能去單獨和資料庫互動取出需要的資訊，詳細情形就不多說。</p>
<p>還有一個功能在圖中沒有呈現，就是關於<code>系統層面</code>的功能，像是<code>帳號管理</code>、<code>使用者引導</code>跟<code>切換語言</code>等其他功能，也會一併規劃在<code>功能層面</code>。</p>
<h1 id="實作-期望與模擬的後端-api-層架構實作">實作: 期望與模擬的後端 API 層架構實作</h1>
<p>我的程式碼沒有公開，也不會在部落格撰寫具體是怎麼實作，所以我設計了一個貼近真實實作的程式碼架構模擬，Miri 內部大致上也是照著這樣去實作的。</p>
<p>接下來的部分就是實作後端 API 層架構層，那麼期望的實作架構與程式碼如下：</p>
<pre><code>Miri
├── api
│   ├── line
│   │   ├── __init__.py
│   │   └── process.py
│   └── telegram
|       ├── __init__.py
│       └── process.py
│
├── features
│   ├── divination
│   │   └── ?
│   ├── conversation
│   │   └── ?
│   └── system
│       └── ?
│
└── Procfile
└── main.py
</code></pre>
<p>規劃上會將<code>FastApi</code>的程式碼實作在 <code>main.py</code> 作為 Api 接口的大門，然後 line 跟 telegram 會分開放在<code>api</code>資料夾中，分別將 Api 程式碼寫在各自資料夾的<code>__init__.py</code>中，在用<code>FastApi</code>的<code>rounter</code>功能將分開在不同檔案的 Api 路徑註冊進 api 的名單中，這樣即便 api 路徑在不同檔案，也能一併成為接口，接收 request 啦！</p>
<h1 id="實作-fastapi">實作: FastApi</h1>
<p>這個部分要換成<code>Flask</code>還是<code>Django</code>或者其他的 WebApi 套件都可以，基本上會使用 FastApi 主要只是因為要離職時同事跟我說過這是目前最快的 Api 套件，基於好奇，就直接拿來使用在 Miri 身上，但我目前在 Miri 身上使用到 FastApi 功能沒有很多，所以就算之後要替換成其他 WebApi 套件，也很簡單。</p>
<p>在專案的根部底層創立<code>main.py</code>成為整個程式驅動的主程式，也就是說當架設於伺服器上時，只要跑<code>main.py</code>就能將整個程式跑起來，將 api 架起來，前端就能使用了</p>
<p><strong>main.py</strong></p>
<pre><code class="language-py">import uvicorn
from fastapi import FastAPI

from api import line, telegram

app = FastAPI()

app.include_router(line.line_api)
app.include_router(telegram.telegram_api)


@app.get("/")
def read_root():
    return {"Hello": "World"}

# Production Setting
# Run on Heroku/ Procfile, run terminal directly
# web: uvicorn main:app --host=0.0.0.0 --port=${PORT:-5000}

# Development Setting
if __name__ == "__main__":
    uvicorn.run(app, host="127.0.0.1", port=8000)

</code></pre>
<p>原則上和 Flask 用法很像，先初始化一個<code>app</code>，而這個<code>app</code>就是代表整個程式及 api 的出入口，然後是將之後會寫在 line 跟 telegram 的 api 路徑註冊進<code>app</code>中，這樣即便 api 沒有寫在主程式，但也會自動將處在不同資料夾的 api 列進能使用的 api。</p>
<pre><code class="language-py"># 初始化一個app，代表整個專案程式的web入口
app = FastAPI()

# 將分散在line跟telegram的 api rounte 註冊進app
app.include_router(line.line_api)
app.include_router(telegram.telegram_api)
</code></pre>
<p>再來寫了一個<code>hello_world</code>來測試架起來後可否呼叫到 api，接著是當正在撰寫程式碼時，需要開啟 debug 模式所寫的設定。</p>
<pre><code class="language-py">@app.get("/")
def read_root():
    return {"Hello": "World"}

# Production Setting
# Run on Heroku/ Procfile, run terminal directly
# web: uvicorn main:app --host=0.0.0.0 --port=${PORT:-5000}

# Development Setting
if __name__ == "__main__":
    uvicorn.run(app, host="127.0.0.1", port=8000)

</code></pre>
<p>最後要提及一下，之後怎麼部署於 <code>Heroku</code> 伺服器上，當所有程式都完成了，要部署於 Heroku 上時，需要把用於開發真錯的程式暫時註解掉。</p>
<pre><code class="language-py"># Development Setting
# if __name__ == "__main__":
#     uvicorn.run(app, host="127.0.0.1", port=8000)
</code></pre>
<p>接著需要在根部底層創一個 <code>Procfile</code> 檔，是部署 Heroku 時，會使用到的部署檔，沒有副檔名！！</p>
<p>接著直接將一行程式貼進<code>Procfile</code>就好</p>
<p><strong>Procfile</strong></p>
<pre><code>web: uvicorn main:app --host=0.0.0.0 --port=${PORT:-5000}
</code></pre>
<p>在 Heroku 中，是將程式執行於 <code>0.0.0.0</code> 並非 <code>127.0.0.1</code>。</p>
<p>之後使用 Github 連接自動部署就能自動將 FastApi 執行起來。</p>
<p>FastApi 的部分就到這為止，我並沒有使用太多功能，只是拿來當 web api 的大門接口而已</p>
<h1 id="實作-line-bot">實作: Line Bot</h1>
<p>再來進到 Line Bot Api 中，我一直在想要怎麼撰寫 Line 跟 Telegram 的教學會比較好，因為其實網路上已經蠻多人撰寫這方面的文章。</p>
<p>但我還是根據自己使用到的功能，加上一些開發需要注意的地方來撰寫此篇幅。</p>
<p><img src="https://minayu0416.files.wordpress.com/2021/09/screen-shot-2021-09-06-at-7.23.10-pm.png" alt=""></p>
<p>這個是我自己畫的架構圖，基本上最左邊是 FastApi 的 api 大門，而 line 的 api 只有一個，就自訂吧，我這邊是定為<code>/api/line/callback</code>。可能會想問，如果 Line 的<code>api</code>只有一個，那要怎麼分辨不同的訊息？這個時候<code>事件Event</code>跟<code>訊息型別MessageType</code>就很重要了。在 Line 中即便 api rounte 路徑只有一個，但主要是依靠訊息的<code>事件Event</code>跟<code>訊息型別MessageType</code>來接收跟回覆不同的訊息。</p>
<h2 id="事件-event">事件 Event</h2>
<p>Event 是比訊息還上一層的概念，我們來看看 Line 中有哪些事件：</p>
<ul>
<li>MessageEvent</li>
<li>FollowEvent</li>
<li>UnfollowEvent</li>
<li>JoinEvent</li>
<li>PostbackEvent</li>
</ul>
<p>還有一些我沒寫上去，基本上 Event 比較像是<code>加入群組</code>, <code>離開群組</code>, <code>訊息動作</code>或其他類似的動作，也就是說一種<code>Event</code>需要一個或多個<code>handler</code>處理程式去處理它，如果你要做的 Event 或者接收到的 Event 沒有特別寫 handler 來處理的話，後端程式也就不會接收到傳過來的 Event 事件，訊息就會卡在 api 層然後報錯。</p>
<p>而我基本上只用到兩個 Event: <code>MessageEvent</code>, <code>PostbackEvent</code>，所以只寫了 3 個 handler:</p>
<ul>
<li>MessageEvent, message=TextMessage</li>
<li>MessageEvent, message=StickerMessage</li>
<li>PostbackEvent</li>
</ul>
<p>剛剛有提到一個 Event 需要<code>一個或多個</code>handler，主要就是在於<code>MessageEvent</code>能有不同的<code>訊息型別Message Type</code>，而每個訊息模式也都需要有一個 handler 來處理。</p>
<h2 id="訊息型別-message-type">訊息型別 Message Type</h2>
<p>Line 的訊息型別蠻多種的，詳細的型別給大家列在下方</p>
<p><strong><a href="https://developers.line.biz/en/docs/messaging-api/message-types/">Message types</a></strong></p>
<p>基本上，從 Api 最開始收到的會是一種 Line 的訊息型別(Message Type)，<strong>而當程式要回傳給 Line 客戶端時，也必須要將訊息包裝成 Line 的 Message Type，才能回傳給客戶端。</strong> 所以就是一律用 Line 的 Message 物件去做溝通傳遞，也請放心即便傳來的是<code>Message物件</code>，裡面也一定夾帶一堆參數，可以讀取其中的訊息或檔案。</p>
<p>在 Miri 當中，我大量的使用 <code>TextMessage</code> 跟 <code>Template message</code>。</p>
<p><code>TextMessage</code>指的是文字訊息，所以如果只要發文字訊息的話，只要將字串包成<code>TextMessage</code>物件再發出去就可以了</p>
<p>而<code>Template message</code>中，我在實作占卜流程時大量運用到了：</p>
<ul>
<li><a href="https://developers.line.biz/en/docs/messaging-api/message-types/#buttons-template">Buttons template</a></li>
<li><a href="https://developers.line.biz/en/docs/messaging-api/message-types/#carousel-template">Carousel template</a></li>
</ul>
<p>這兩個訊息點擊按鈕後觸發的事件叫做<code>PostbackEvent</code>，所以如果有需要用到<code>Template message</code>來回覆訊息的話，記得加上<code>PostbackEvent</code>的 handler 來處理使用者按下按鈕之後的操作。</p>
<p>總之 Line Bot 也是一門有趣的學問，我可能只用到了 20-30%Line Bot 的功能來實作 Miri 的前端，有興趣的人可以多加鑽研，而我的文章也沒有說撰寫的很詳細，因為主要是紀錄 Miri 使用了哪些功能，不過只要有架構圖跟 api 的實作做完後，基本上後續的施工就依照每個人需求不同的功能各自去研究。</p>
<h2 id="實作-api--handler">實作: Api &#x26; handler</h2>
<p>以上講了很多，接下來就實作 api 的部分，來看一下上面的架構圖</p>
<pre><code>Miri
├── api
│   ├── line
│   │   ├── __init__.py
│   │   └── process.py
│   └── telegram
|       ├── __init__.py
│       └── process.py
...
...
└── Procfile
└── main.py
</code></pre>
<p>先前已經將 FastApi 實作於<code>main.py</code>，這次要將 Line Api 實作於 <code>./api/line/__init__.py</code> 當中</p>
<p><code>./api/line/__init__.py</code></p>
<pre><code class="language-py">import configparser
from datetime import datetime

from fastapi import APIRouter, HTTPException, Request

from linebot.models import *

from linebot import (
    LineBotApi, WebhookHandler
)
from linebot.exceptions import (
    InvalidSignatureError
)

from log import logger
from process import processor, MsgEvent


# Load data from config.ini file
# 通常重要資訊不會寫死在程式碼，會用環境變數檔存著，所以用此套件讀取出重要資訊
config = configparser.ConfigParser()
config.read('config.ini')

# Access Token 跟 Secret 要去Line網頁中，你創的頻道內的設定觀看
# Channel Access Token
line_bot_api = LineBotApi(config['LINE']['ACCESS_TOKEN'])

# Channel Secret
handler = WebhookHandler(config['LINE']['CHANNEL_SECRET'])

# 這個部分就是開一個FastApi的Router，所有使用Router的Api Url都會註冊成為可以使用的api
line_api = APIRouter()

# 將 /api/line/callback 註冊進 line_api Router內
# 主要的api入口，接收所有的request
@line_api.post("/api/line/callback")
async def callback(request: Request):

    # get X-Line-Signature header value
    # 這個部分是要從header取得Line特有的參數或簽名參數，需要和Line官方比對，有誤就會報錯
    signature = request.headers['X-Line-Signature']

    # get request body as text
    body = await request.body()
    body = body.decode('utf-8', 'replace')

    # 這是我寫的logger, 可以刪除
    logger().debug("Request body: " + body)

    # handle webhook body
    # 透過接收到的訊息類型來分配到要進入哪個handler
    try:
        handler.handle(body, signature)

    except Exception as e:
        logger().error("ERROR: " + str(e))

    except InvalidSignatureError:
        HTTPException(400)
    return 'OK'


# 處理文字訊息
@handler.add(MessageEvent, message=TextMessage)
def handle_message(event):
    """
    TextSendMessage(text = type(str))
    """

    # 基本上各項元素都包在Event物件中
    user_id = event.source.user_id
    user_type = event.source.type
    send_time = datetime.fromtimestamp(event.timestamp / 1000)
    msg_type = event.message.type
    message = event.message.text

    # 這個我寫的，主要是因為我需要將傳來的事件統一變成另外一個我自己寫的物件，方便和後端溝通
    msg_event = MsgEvent("line", user_type, user_id, send_time, msg_type, message)
    response = processor.analyze(msg_event)

    # logger 也是我寫的
    logger().debug("Reply response: " + str(response))

    # 這一步就是回覆給客戶端，注意response 是 list型別
    line_bot_api.reply_message(event.reply_token, response)


# 處理貼圖訊息
@handler.add(MessageEvent, message=StickerMessage)
def handle_message(event):
    import random
    # 貼圖的部分沒怎麼做，就是從1-21個表情包隨便選一個回覆，使用者傳貼圖，我也回傳貼圖
    message = StickerSendMessage(
        package_id='1',
        sticker_id='{}'.format(random.randint(1, 21))
    )
    logger().debug("Reply response: " + str(message))
    line_bot_api.reply_message(event.reply_token, message)


@handler.add(PostbackEvent)
def handle_message(event):
    import json
    # 基本上 Template Message 傳出去前先要將每個按鈕的訊息壓成json
    # 所以Postback回傳的訊息會是json
    data = event.postback.data
    data = json.loads(data)
    user_id = event.source.user_id
    user_type = event.source.type
    send_time = datetime.fromtimestamp(event.timestamp / 1000)

    # 處理訊息的部分，你可以替換成任何你想怎麼處理訊息就怎麼處理訊息
    msg_event = MsgEvent("line", user_type, user_id, send_time, "option", data)
    response = msg_processor.analyze(msg_event)

    # 自己寫的logger
    logger().debug("Reply response: " + str(response))

    # 回覆給客戶端，注意response 是 list型別
    line_bot_api.reply_message(event.reply_token, response)

</code></pre>
<p>很長一段，但大部分的步驟都有寫上註解了，將幾個比較重要的地方寫出來。</p>
<ol>
<li>Line 的 Access Token 跟 Secret</li>
</ol>
<p>這兩個 Token 能夠在你在 Line 網頁上管理機器人的頁面設定中找到，建議最好不要寫死在程式碼中，最好是使用類似<code>.ini</code>,<code>.config</code>,<code>.env</code>之類的隱藏檔案做開發，或者加密儲存在資料庫，因為當這兩個 token 被偷走後，機器人頻道就等於整個被偷走。</p>
<ol start="2">
<li>APIRouter</li>
</ol>
<p>記得在實作 Line api 接口時，要創建 FastApi 的 router，我們用 code 展現一下</p>
<p><strong>line/<strong>init</strong>.py</strong></p>
<pre><code class="language-py">from fastapi import APIRouter

# 我們在Line的api檔案中開一個FastApi的Router，用來將api串進fastapi接口，使其可使用
line_api = APIRouter()

# 將 /api/line/callback 註冊進 line_api Router內
@line_api.post("/api/line/callback")
async def callback(request: Request):
    pass

</code></pre>
<p>接著回到先前就已經實作過的 FastApi <code>main.py</code></p>
<pre><code class="language-py">from api import line, telegram

app = FastAPI()

# 可以看到我們將上面在line檔案中實作的api rounter註冊進app中，使其可以使用
app.include_router(line.line_api)

# Telegram 也是一樣的道理
app.include_router(telegram.telegram_api)

</code></pre>
<ol start="3">
<li>handler &#x26; event</li>
</ol>
<p>根據上方程式碼，我們可以看到我寫了三個 handler</p>
<pre><code class="language-py">
# 處理文字訊息
@handler.add(MessageEvent, message=TextMessage)
def handle_message(event):
    """
    TextSendMessage(text = type(str))
    """

    # 基本上各項元素都包在Event物件中
    user_id = event.source.user_id
    user_type = event.source.type
    send_time = datetime.fromtimestamp(event.timestamp / 1000)
    msg_type = event.message.type
    message = event.message.text

    # TODO 看你怎麼處理他囉！但是要記得response要是list型別
    response = processor.analyze(msg_event)

    # 這一步就是回覆給客戶端，注意response 是 list型別
    line_bot_api.reply_message(event.reply_token, response)


# 處理貼圖訊息
@handler.add(MessageEvent, message=StickerMessage)
def handle_message(event):
    # TODO 處理
    line_bot_api.reply_message(event.reply_token, message)


@handler.add(PostbackEvent)
def handle_message(event):
    # 處理
    line_bot_api.reply_message(event.reply_token, response)
</code></pre>
<p>在每一個處理的函式中，你需要用裝飾器 decorator 來標示這個函式是一個 Line 訊息的 handler，接著要在 handler 的參數中標明這個 handler 是要處理什麼事件/訊息。</p>
<pre><code class="language-py">@handler.add(MessageEvent, message=TextMessage)
</code></pre>
<p>這個部分是回覆訊息，程式處理完的回覆記得將他依照需求變成 Line Message 物件，然後放進 list 中</p>
<pre><code class="language-py">line_bot_api.reply_message(event.reply_token, response)
</code></pre>
<p>簡單來說 <code>response = [message_obj, message_obj]</code></p>
<p>接著，傳來的 event 會夾帶一些參數，大致上需要用到的參數都會有</p>
<pre><code class="language-py">def handle_message(event):
    # ---------------^ 就是這個傳來的event
    pass
</code></pre>
<p>基本上傳來的事件參數可得知：</p>
<ul>
<li>使用者 ID</li>
<li>使用者型別, 私人或是群組</li>
<li>傳訊息的時間</li>
<li>訊息類別</li>
<li>訊息本身</li>
</ul>
<p>這邊要特別說一件事是 Line 的時間，我研究很久，因為他既很像 timestamp，但是轉換過來的時間又不正確，Line 的文件是寫 <code>Unix Time</code>，我最後是將讀到的時間除以 1000 再將其從 timestamp 轉為 datetime 才取到正常時間，不過是 UTC 時間，所以台灣時間是<code>+8小時</code>，記得要+上 8 小時再使用它。</p>
<h2 id="選單-menu">選單 Menu</h2>
<p>Line 的選單有兩種方式可以做成</p>
<ul>
<li>Line 官方帳號管理網頁設定</li>
<li>透過 Line Bot Api 設定</li>
</ul>
<p>很抱歉讓你們失望了，身為後端工程師！！！</p>
<p>我沒有使用 Line Bot Api 做成選單 XD，因為當時我給自己實作 Miri 的時間已經超過了，再加上我覺得看起來選單這個功能如果用 Line Bot Api 做，不熟，看不懂，感覺很難 XD，在 Deadline 大敵將至，我還是決定用第一個方式做哈哈！</p>
<p>這是我做的選單，也是現在 Miri 在用的，也有被我朋友砲轟說是要做多簡單，乾脆他幫我畫！</p>
<p>畫畫不是我的強項！！！我用 Mac 的 KeyNote 拉出了我覺得可以接受的選單頁面就好，總之功能先到位比較重要！</p>
<p>如果是用<code>Line 官方帳號管理網頁設定</code>來做選單就會比較簡單，請到 <strong><a href="https://manager.line.biz/">Line 官方帳號管理網頁</a></strong>，登入後，選擇你之前創建的 Bot 帳號。</p>
<p><code>主頁</code> > <code>聊天室相關</code> > <code>圖文選單</code>，接著就能找到創建圖文選單的地方。</p>
<p>點選<code>建立</code>，建立新的選單，比較重要的就是版型，目前官方提供像是圖中這麼多種版型，就依照個人需求選擇</p>
<p>我先隨便選了一個版型，接著右邊就有對應版型的動作類型可以選擇，然後左邊的設定也能夠上傳照片</p>
<p><img src="https://mingjungyu.files.wordpress.com/2021/09/screen-shot-2021-09-07-at-5.18.59-pm.png" alt=""></p>
<p><code>按鈕動作</code>提供了 6~7 種，但對我幫助比較大的只有文字，我還在妄想有沒有可能可以設定 CallBack 按鈕 qq，所以最後我做的選單只有按下去發送文字，然後 Miri 再根據文字去判斷要回送什麼訊息。</p>
<h2 id="line-bot-的一些注意細節">Line Bot 的一些注意細節</h2>
<ol>
<li>如果程式處理時間太久，會被 Line 判定超過時效，不會回覆使用者訊息</li>
</ol>
<p>我常常會用 debug 模式去追我程式到底哪邊寫錯，有時候甚至會直接在錯誤的地方一步一步看傳遞的參數，結果就發現如果訊息太久沒有回給客戶端，Line 就會有時間到期的問題，而直接跳錯，不會回覆。</p>
<p>感覺這算 Line 比較嚴謹的地方，所以估計 Line Bot 後面的程式也不太適合拿來做大量的運算或者複雜的功能，目前沒測過最久能接受多久，但如果在 Debug 模式或者程式跑太久後報錯，可能就是反應時間超過 Line 定的時效囉！</p>
<ol start="2">
<li>可以一次回上限五個訊息</li>
</ol>
<p>不管是 Line 還是 Telegram，回覆是使用 list 中可包含許多 Message 物件，所以代表可以回覆多個訊息，比方說小明對 Bot 丟了一個 <code>Hello</code>，則機器人可以回說: <code>Hello 您好！</code>, <code>請問要選擇哪個食物？</code>, <code>食物的Carousel template message</code>。</p>
<pre><code class="language-py">response = [msg, msg, msg]
</code></pre>
<p>上限是五個訊息，超過就會報錯！</p>
<ol start="3">
<li>Template Message 的字數問題</li>
</ol>
<p>我承認！在開發時，我沒有好好看 api 文章 XD</p>
<p>要記得在開發 Template Message 相關的訊息型別時，參考一下 api 文件，因為他的每個參數都會有一些限制。</p>
<p>例如:</p>
<ul>
<li>Carousel template 的 columns 最多只能放 10 個</li>
<li>Button template 的 button actions 最多只能放 4 個按鈕</li>
<li>Button template 的 title 最多只能 40 個字(40 個中文或日文字當標題應該完全足夠，慘的是英文字母，所以感覺 Line 不太適合給英文使用者開發 XD，因為我光要想辦法把英文要能詞達意又要限制在固定的字數中，花了很大的功夫)</li>
</ul>
<p>總之就是開發時或者規劃時多看一下 api 文件就是！</p>
<p>但最令人羨慕的是 Button 的 Postback action 竟然可以多達 300 個字！！等於在 action 中塞一個很長一串的 dictionary 或者 json 都沒事，這個部分在 Telegram 非常麻煩，因為 Telegram 的 postback 有限字數 XDD</p>
<ol start="4">
<li>訊息處理失敗了就重新從前端/Line 訊息平台重新發一次 Request</li>
</ol>
<p>這個部分基本上沒什麼問題，就是如果在開發時反覆測試，每次都從 Line 聊天室發訊息來後端測試功能，如果失敗了就是 request 直接失效，那就再從 Line 聊天室再發一次訊息。</p>
<p>為什麼提到這點，主要是因為 ...</p>
<p><strong><em>Telegram 就算程式處理失敗了，發過的 Request 若沒有處理或回覆的話，短時間內將會一直流浪在網路上，直到你的程式寫好/修好之前，他都會不斷的是同一個 request 往程式的 api 發，不斷的發。</em></strong></p>
<h1 id="實作-telegram-bot">實作: Telegram Bot</h1>
<p>接下來就來寫 Telegram Bot 的部分啦！</p>
<p>Telegram bot 是此次的新功能之一，我覺得它的 bot 機制和 Line 其實蠻相似的，所以實作邏輯不會有太大的問題，但訊息型別的精緻度會稍微比 Line 差一點點，還有一個特點是<code>PostBack</code>的<code>callback_data</code>參數字數不能超過 64 個字，所以幾乎隨便塞一個 dictionary 進<code>callback_data</code>，很快就爆了，方法我待會會在下面說。</p>
<p>Telegram Bot 說是和 Line Bot 相似也能說不太相似，總之邏輯都是 Bot，所以 Api 接口的寫法都蠻像的，但是深入核心的部分就會發現這兩種 Bot 會是呈現兩種完全不同的功能，倒也不是說不能整合，只是需要做一點轉換。</p>
<p>還有就是我發現我看不太懂 Telegram 的文件 XD</p>
<h2 id="訊息處理者-handler">訊息處理者 Handler</h2>
<p>和 Line 一樣，Telegram 也會有訊息 Handler，如果沒有撰寫函式處理相對應的動作或事件，Bot 也是一樣不會有反應。</p>
<p>這邊舉例兩個我用的 Handler:</p>
<ul>
<li>MessageHandler: 顧名思義就是處理任何訊息的訊息
<ul>
<li>filter.text</li>
<li>filter.audio</li>
<li>filter.command</li>
<li>filter.document</li>
</ul>
</li>
<li>CallbackQueryHandler: 處理任何透過按鈕觸發的 Callback 動作
<ul>
<li>handle_callback</li>
</ul>
</li>
</ul>
<p>這個概念跟 Line 很相似，<code>MessageHandler</code>是一個 <code>Handler</code>，但還是要特別標注他是處理哪種訊息，比方說 <code>filter.text</code> 專門處理文字，<code>filter.audio</code>專門處理音訊。</p>
<p>所以假設你要一個 Bot 處理<code>文字</code>，<code>檔案</code>，<code>音訊</code>，就變成要增加三個 Handler:</p>
<ul>
<li>MessageHandler(Filters.text, handle_message)</li>
<li>MessageHandler(filter.document, handle_message)</li>
<li>MessageHandler(filter.audio, handle_message)</li>
</ul>
<p>詳細程式碼下面會寫</p>
<h2 id="message-type-訊息型別">Message Type 訊息型別</h2>
<p>一些基本的訊息型別會有，包含<code>文字</code>，<code>圖像</code>，<code>影片</code>，還有一些其他的訊息型別</p>
<p>有興趣再麻煩參照 <strong><a href="https://core.telegram.org/bots/api#available-types">Telegram Bot Api 文件</a></strong> 啦！</p>
<p>比較讓我燒腦的是 Telegram Bot 沒有像 Line 的 <code>Carousel Template</code>的訊息，有提供的是<code>InlineKeyboardMarkup</code>跟<code>InlineKeyboardButton</code>型別，來看一下他的效果為何？</p>
<p><strong><em>想不想來占卜一下？ 哈哈</em></strong></p>
<p>總之<code>InlineKeyboardMarkup</code>跟<code>InlineKeyboardButton</code> 是擁有按鈕的訊息，上面那個照片中其實是兩個訊息: <code>Photo</code> + (<code>InlineKeyboardMarkup</code> + <code>InlineKeyboardButton</code>)，所以真實的效果是沒有照片的，而圖片中的整組訊息就是我想出來可以代替 Line 的 Button Template 訊息呈現於 Telegram 的替代方案，這個部分下方會說明。</p>
<p>總之，也許有其他訊息型別更適合，但就待各位去官方文件挖寶了。</p>
<h2 id="創建一個-telegram-bot">創建一個 Telegram Bot</h2>
<p>Telegram Bot 的創建和 Line 有一點點不一樣，Telegram 沒有像 Line 一樣完整的官方帳號管理頁面，也許本來這兩個機器人面對的客群就不同，要創建 Telegram Bot 你需要先找到他爸爸！</p>
<p><strong><a href="https://t.me/BotFather">BotFather</a></strong></p>
<p>不是跟你開玩笑吧 XD</p>
<p>進去之後，BotFather 就會寄很多創建 Bot 相關的指令，創建 Bot 跟刪除 Bot 蠻簡單的，所以如果操作不當就刪掉重創吧！</p>
<p>從<code>/newbot</code>開始</p>
<ul>
<li>先取名字</li>
<li>再取 username，他會像是唯一的<code>@</code> id</li>
<li>創建後，會給你一串 Token</li>
</ul>
<p>比較需要注意的是 bot 的 username，就是類似 Bot 的 Id，用<code>@</code>包裝的 Id，這個名字一定要含<code>bot</code>，所以你可以取 <code>TetrisBot</code> 或 <code>tetris_bot</code> 就看個人發揮，就是要有 bot 字在裡面。</p>
<p>然後那串 token 很重要，是未來需要連接 Bot 到後端程式所需要的 Token，丟了也可以透過 BotFather 再創建，不用擔心！</p>
<p>接下來就進入到實作 APi 的部分！</p>
<h2 id="實作-api--handler-1">實作 Api &#x26; Handler</h2>
<p>接下來一樣進到實作的部分，來看一下上面的架構圖</p>
<pre><code>Miri
├── api
│   ├── line
│   │   ├── __init__.py
│   │   └── process.py
│   └── telegram
|       ├── __init__.py
│       └── process.py
...
...
└── Procfile
└── main.py
</code></pre>
<p>先前已經將 FastApi 實作於<code>main.py</code>，這次要將 Telegram Api 實作於 <code>./api/telegram/__init__.py</code> 當中</p>
<p><code>./api/telegram/__init__.py</code></p>
<pre><code class="language-py">import configparser
from datetime import timedelta

from fastapi import APIRouter, HTTPException, Request

import telegram
from telegram import Update, Bot
from telegram.ext import Dispatcher, MessageHandler, CallbackQueryHandler, Filters, CallbackContext

from process import MsgEvent, processor


# 建議將Token存入環境變數檔或者資料庫中
config = configparser.ConfigParser()
config.read('config.ini')

# 一樣需要用FastApi的Router功能初始化telegram_api
telegram_api = APIRouter()

# 還記得上面說的Token嗎？要寫在這邊
bot = telegram.Bot(token=(config['TELEGRAM']['ACCESS_TOKEN']))

# 這邊一樣，將 /api/telegram/hook 註冊於 rounter中
@telegram_api.post('/api/telegram/hook')
async def webhook_handler(request: Request):
    """Set route /hook with POST method will trigger this method."""
    body = await request.json()

    update = telegram.Update.de_json(body, bot)

    # 需要將來的事件丟進handler
    dispatcher.process_update(update)
    return 'ok'


def handle_message(update: Update, context: CallbackContext):
    """Reply message."""
    text = update.message.text
    user_id = update.message.chat.id
    user_type = update.message.chat.type

    send_time = update.message.date + timedelta(hours=8)

    # 處理的部分
    msg_event = MsgEvent("telegram", user_type, user_id, send_time, "text", text)
    response = msg_processor.analyze(msg_event)

    # 這邊示範寄出照片跟文字訊息
    bot.send_photo(update.message.chat_id, photo=response.photo)
    bot.send_message(update.message.chat_id, response.text)


def handle_callback(update: Update, context: CallbackContext):
    """Reply message."""
    data = update.callback_query.data
    user_id = update.callback_query.message.chat.id
    user_type = update.callback_query.message.chat.type

    send_time = update.callback_query.message.date + timedelta(hours=8)

    # 處理的部分，請各位自由發揮
    msg_event = MsgEvent("telegram", user_type, user_id, send_time, "option", data)
    response = msg_processor.analyze(msg_event)

    # 這邊示範寄出照片跟文字訊息
    bot.send_photo(update.callback_query.message.chat_id, photo=response.photo)
    bot.send_message(update.callback_query.message.chat_id, response.text)


# New a dispatcher for bot
dispatcher = Dispatcher(bot, None)

# 需要新增 Handler 來處理特定的訊息跟動作
dispatcher.add_handler(MessageHandler(Filters.text, handle_message))
dispatcher.add_handler(CallbackQueryHandler(handle_callback))

</code></pre>
<p>跟上方的 Line Api 實作方式很相似，幾個注意的要點，一樣提醒大家</p>
<ol>
<li>Telegram token 建議使用 <code>config</code>, <code>.env</code>檔案儲存或者存入資料庫</li>
</ol>
<p>記得利用 token 初始化一個 telegram 的 bot，會需要使用 bot 做回覆訊息的功能</p>
<pre><code class="language-py"># 還記得上面說的Token嗎？要寫在這邊，初始化你的Telegram Bot
bot = telegram.Bot(token=(config['TELEGRAM']['ACCESS_TOKEN']))
</code></pre>
<ol start="2">
<li>記得要新增你想處理的訊息/動作的 Handler</li>
</ol>
<pre><code class="language-py"># 需要新增 Handler 來處理特定的訊息跟動作
dispatcher.add_handler(MessageHandler(Filters.text, handle_message))
dispatcher.add_handler(CallbackQueryHandler(handle_callback))
</code></pre>
<p>以這個例子來說是處理 <code>訊息動作</code> 的 <code>文字訊息</code>跟 <code>Callback動作</code></p>
<ul>
<li>MessageHandler(Filters.text, handle_message)</li>
<li>CallbackQueryHandler(handle_callback)</li>
</ul>
<p>所以假設你要處理客戶端傳來音訊，那就是以此類推：</p>
<ul>
<li>MessageHandler(Filters.audio, handle_message)</li>
</ul>
<p>詳細情況再麻煩爬文 Python 的 <strong><a href="https://github.com/python-telegram-bot/python-telegram-bot">Telegram 套件</a></strong></p>
<ol start="3">
<li>記得要將 Telegram 的 api route 透過 FastApi APIRouter 加入路徑</li>
</ol>
<pre><code class="language-py">telegram_api = APIRouter()

@telegram_api.post('/api/telegram/hook')
async def webhook_handler(request: Request):
    pass

</code></pre>
<ol start="4">
<li>注意由一般訊息來的參數跟從 callback 動作來的參數會在不同地方</li>
</ol>
<pre><code class="language-py"># 以取user_id為例

# 一般訊息從update.message來
user_id = update.message.chat.id

# Callback 的參數會在callback_query內
user_id = update.callback_query.message.chat.id

</code></pre>
<ol start="5">
<li>寄出去的訊息型別</li>
</ol>
<p>在 Telegram 中傳送文字訊息跟圖片不用特別轉換成另外一種訊息物件，寄圖片有寄圖片的函式<code>send_photo</code>，重送訊息也有傳送訊息的函式 <code>send_message</code>，只是參數中無論是 photo 還是 text 都要塞字串。</p>
<pre><code class="language-py">bot.send_photo(update.message.chat_id, photo=response.photo)
bot.send_message(update.message.chat_id, response.text)
</code></pre>
<p>再來，我用的按鈕訊息，也是用<code>send_message</code>來發送訊息，唯一不同的是，需要多帶一個參數</p>
<pre><code class="language-py">
# 你需要用`InlineKeyboardMarkup`跟`InlineKeyboardButton`兩個物件做出你要的訊息模式，再帶入reply_markup中，所以資訊會長這樣

markup =
InlineKeyboardMarkup([
    InlineKeyboardButton("button1", "{'action': push}"),
    InlineKeyboardButton("button2", "{'action': pull}"),
    InlineKeyboardButton("button3", "{'action': cut}")
])

bot.send_message(chat_id, text, reply_markup=markup)

</code></pre>
<p>換你實作啦！</p>
<h2 id="telegram-bot-的一些注意細節">Telegram Bot 的一些注意細節</h2>
<ul>
<li>Request 若沒得到回應，會一直重複對 api 發送</li>
</ul>
<p>這點和 Line 不同，Telegram 的 Request 沒有短時效問題，所以如果 Request 沒有得到回覆（也就是可能在跑程式的某個地方報錯），那那個 Request 會一直循環在網路雲端中，然後不斷地往 api 發送直到取得答案為止，我有點忘記時效多少，但我記得好像...一天內失敗的 Request 都會活著。</p>
<p>如果不幸在測試程式時，發送 Request 太多失敗，那就 Debug 模式繼續開著等剛剛發送的 Request 會延遲幾秒後再次自動向 api 發送。</p>
<ul>
<li>CallBack Data 參數有限制</li>
</ul>
<p>如果要用 <code>InlineKeyboardButton</code>當作按鈕做出 Callback 行為，要注意一下 <code>callback_data</code>不能超過 64 的字，由於我是塞字典，所以一下就爆字數了，文件在此 <a href="https://core.telegram.org/bots/api#inlinekeyboardbutton">InlineKeyboardButton</a>。</p>
<p>我的參數：</p>
<pre><code class="language-py"># 隨隨便便寫的字典就48個字了
InlineKeyboardButton(callback_data=str({"category": "communication", "action": "flirt"}))
</code></pre>
<p>當然你也可以直接就寫文字，例如:</p>
<pre><code class="language-py"># 寫中文字完全OK
InlineKeyboardButton(callback_data=str("會話，調情"))
</code></pre>
<p>看個人發揮，我個人是塞字典，比較好我後端程式後續的程式操作，但又很容易爆字！</p>
<p>所以我的一個作法是，我在 CallBack 訊息傳出去跟傳回來時做了一個<code>壓縮器/加密器</code>，將超過長度的 <code>callback_data</code>透過演算法或加密法壓縮成 64 個字內，回來時再用一樣的方式解密，這樣就能夠解決 64 個字限制的問題！</p>
<ul>
<li>InlineKeyboardButton 按鈕寬度跟排列</li>
</ul>
<p>在實作 Button 訊息時，老實說我也有遇到如果我的按鈕字數太長，他就會被遮住，比方說：</p>
<pre><code># 例如這樣字就會被壓縮到！

[Runes][Tarot][Leno..][Moon..]

</code></pre>
<p>可是我希望字可以全部顯示，希望能夠將按鈕加寬。Telegram 沒能讓按鈕加寬，但可以透過按鈕的排列來使按鈕加寬，這邊給些例子參考</p>
<pre><code># 假設完整是這樣
markup =
InlineKeyboardMarkup([
    InlineKeyboardButton("button1", "{'action': push}"),
    InlineKeyboardButton("button2", "{'action': pull}"),
    InlineKeyboardButton("button3", "{'action': cut}")
])
</code></pre>
<pre><code>
# 我們將一些字簡略，比較好展示

Markup(
    [Button(), Button()]
)

</code></pre>
<pre><code>
# 我們將一些字簡略，比較好展示

Markup(
    [
        [Button()],
        [Button()],
        [Button()],
        [Button()],
        [Button()],
        [Button()]
        ]
)

</code></pre>
<pre><code>
# 我們將一些字簡略，比較好展示

Markup(
    [
        [Button()],
        [Button(), Button()],
        [Button(), Button()],
        ]
)

</code></pre>
<p><strong>簡單來說就是用 list 來去分割按鈕</strong></p>
<h2 id="選單-menu-1">選單 Menu</h2>
<p>再來也是 Telegram 的選單，Telegram 的選單基本上沒有像 Line 那樣的華麗，如圖，這是 Miri 的選單</p>
<p>蠻乾淨簡單的，是用 <code>/command</code>的動作作為選單按鈕，然後最一開始 Menu 會向上方圖一樣，在文字輸入匡左方會多一個 Menu，然後可以縮放跟展開。</p>
<p>Menu 的設定也是呼叫 機器人的爸爸 XD，<strong><a href="https://t.me/BotFather">BotFather</a></strong>，來設定選單</p>
<p>在 Telegram 中不是 Set Menu，而是<code>setcommands</code>。</p>
<p>格式如下：</p>
<pre><code>command1 - Description
command2 - Another description
</code></pre>
<p>你可以一次把要設定的 command 打齊一次送出去！</p>
<p>就有美美簡約的選單囉！</p>
<h2 id="困難克服-訊息於不同平台的呈現方式">困難克服: 訊息於不同平台的呈現方式</h2>
<p>在實作於 Line Bot 跟 Telegram Bot 遇到的一個困難是，由於這兩個後端是共用程式，所以期望上希望兩者呈現的功能要一致，簡單來說就是當點下<code>占卜</code>按鈕時，要跳出六個<code>占卜方法</code>，我希望是圖文並茂，這在 Line Bot 上，用<code>Carousel message</code>可以完美辦到:</p>
<p>但是在 Telegram 就不是這麼一回事了，因為 Telegram 沒有 <code>Carousel message</code>，所以在這個單元想來介紹一下，我是怎麼改動流程盡量讓兩邊平台訊息一致的。</p>
<p>首先是選單目錄，在 Line 使用<code>Carousel message</code>，在 Telegram 用<code>InlineKeyboardMarkup</code></p>
<p><strong><em>可以往右滑</em></strong></p>
<p><strong><em>在 Telegram 的呈現上會稍微遜色，畢竟沒有圖片輔佐</em></strong></p>
<p>所以在規劃使用者流程時，我會特地讓 Line <code>Carousel message</code>變成像是<code>列表</code>的邏輯，當點進去單個項目，才是進到那個項目的動作，來展現一下</p>
<p>點選<code>Click</code>後，兩邊訊息會一致</p>
<p><strong><em>Line 點選後會進到 Button Message，用一個感覺多此一舉的步驟來緩和 Telegram 沒有辦法圖文兼具的窘境。</em></strong></p>
<p><strong><em>接著我們來看一下 Telegram 方，使用了 Photo + InlineKeyboardMarkup 兩個訊息的 Combo 連發達成像 Line 的效果，緩和解決了沒有圖片的問題。</em></strong></p>
<p>由於本人算是第一次做這種前端有兩個以上的平台，先前都是後端對到前端，我相信很多厲害的 app 或網站，兩者兼具的軟體都需要具備這種面對兩種平台以上的後端程式設計，而這是我第一次面對，所以難免在處理上會比較尷尬一點。</p>
<p>也許這也就能夠理解為什麼有些軟體有些功能在網頁上是沒有的，但是在 app 上有，也許就是因為沒辦法做到兩邊展現同樣的效果跟體驗，所以必須有一方是犧牲的。</p>
<p>這是我目前短暫想出的方式，也許會讓 Line 使用者在使用上有點多此一舉跟卡卡的感覺。期望未來如果我實作前端網頁跟 mobile 版本後，就不需要糾結於這個問題，但也有可能未來即便出了網頁跟手機端，還是會保留機器人版本(說不定喔！)</p>
<p>好啦，這篇應該是產品技術文章中最長的文章，能看到這邊的人也蠻厲害的了(還是只會有我看得到 XD)</p>
<p>多謝支持啦！</p></div></article></div></div></div><div class="lg:w-1/3 w-full lg:h-auto lg: mt-6 lg:mt-0"><div class="px-4"><div><div class="mb-10 border border-solid py-4"><p class="font-bold text-center text-gray grid-subtitle text-md">ABOUT ME</p></div><div class="flex items-center justify-center"><img class="object-cover rounded-full" width="175" height="175" src="/static/img/logo.jpg" alt="Author Profile"/></div><p class="leading-relaxed text-md text-center pt-3 pb-3 px-2 motto-block">嗨，我是Mina. 一個ENTP奇女子，時常可以隨手拈來創意的Idea，正向､ 活躍且浪漫。是軟體開發工程師､ 部落客，還是多語學習者，喜歡去探索不同的文化跟發明些東東。</p><p class="leading-relaxed text-2xl text-center pt-1 pb-4 motto-block">@MinaYu Signed</p><div class="border border-solid py-4"><p class="font-bold text-center text-gray grid-subtitle text-md">BLOG STATS</p></div><div class="my-5 pl-5 font-bold font-voll"><span id="busuanzi_container_site_pv"><p class="pb-2">Visits: <span id="busuanzi_value_site_pv"></span></p></span><span id="busuanzi_container_site_uv"><p>Visitors: <span id="busuanzi_value_site_uv"></span></p></span></div></div><div class="mb-5 border border-solid py-4"><p class="font-bold text-center text-gray grid-subtitle text-md">CATEGORY</p></div><div><a href="/categories/software-development/" class="blog-link-style"><div class="py-3 text-sm border-b border-solid font-fondamento">軟體開發 SWD<!-- --> <span class="font-color-gold-1">(<!-- -->105<!-- -->)</span></div></a><div class="list-disc list-inside ml-4 text-gray-600"><a class="link-unstyled" href="/categories/building-diary-of-website-and-blog/"><div class="py-3 text-sm border-b border-solid font-fondamento">網頁與部落格的建築日記<!-- --> <span class="font-color-gold-1">(<!-- -->22<!-- -->)</span></div></a><a class="link-unstyled" href="/categories/frontend-senior-training-plan/"><div class="py-3 text-sm border-b border-solid font-fondamento">[前端] 前端小菜鳥的成長計畫<!-- --> <span class="font-color-gold-1">(<!-- -->11<!-- -->)</span></div></a><a class="link-unstyled" href="/categories/10000-hours-backend-senior-training-plan/"><div class="py-3 text-sm border-b border-solid font-fondamento">[後端] 1萬小時 - 後端工程師養成計劃<!-- --> <span class="font-color-gold-1">(<!-- -->39<!-- -->)</span></div></a><a class="link-unstyled" href="/categories/architectural-design-and-solutions/"><div class="py-3 text-sm border-b border-solid font-fondamento">架構設計與構思創新解決方案<!-- --> <span class="font-color-gold-1">(<!-- -->10<!-- -->)</span></div></a><a class="link-unstyled" href="/categories/working-travel-diary/"><div class="py-3 text-sm border-b border-solid font-fondamento">工作旅行記<!-- --> <span class="font-color-gold-1">(<!-- -->10<!-- -->)</span></div></a><a class="link-unstyled" href="/categories/crasy-master-paper/"><div class="py-3 text-sm border-b border-solid font-fondamento">[專案] 碩論也瘋狂<!-- --> <span class="font-color-gold-1">(<!-- -->13<!-- -->)</span></div></a></div></div><div><a href="/categories/mysticism-and-numerology/" class="blog-link-style"><div class="py-3 text-sm border-b border-solid font-fondamento">神秘學與命理研究談<!-- --> <span class="font-color-gold-1">(<!-- -->26<!-- -->)</span></div></a><div class="list-disc list-inside ml-4 text-gray-600"><a class="link-unstyled" href="/categories/divination/"><div class="py-3 text-sm border-b border-solid font-fondamento">占卜<!-- --> <span class="font-color-gold-1">(<!-- -->5<!-- -->)</span></div></a><a class="link-unstyled" href="/categories/temple-and-buddha/"><div class="py-3 text-sm border-b border-solid font-fondamento">寺廟與佛<!-- --> <span class="font-color-gold-1">(<!-- -->2<!-- -->)</span></div></a><a class="link-unstyled" href="/categories/mysticism/"><div class="py-3 text-sm border-b border-solid font-fondamento">神秘學相關<!-- --> <span class="font-color-gold-1">(<!-- -->6<!-- -->)</span></div></a><a class="link-unstyled" href="/categories/chart/"><div class="py-3 text-sm border-b border-solid font-fondamento">命理學與命盤<!-- --> <span class="font-color-gold-1">(<!-- -->13<!-- -->)</span></div></a></div></div><div><a href="/categories/life/" class="blog-link-style"><div class="py-3 text-sm border-b border-solid font-fondamento">日常生活<!-- --> <span class="font-color-gold-1">(<!-- -->42<!-- -->)</span></div></a><div class="list-disc list-inside ml-4 text-gray-600"><a class="link-unstyled" href="/categories/anxiety-anti-diary/"><div class="py-3 text-sm border-b border-solid font-fondamento">我的焦慮對抗日記<!-- --> <span class="font-color-gold-1">(<!-- -->4<!-- -->)</span></div></a><a class="link-unstyled" href="/categories/life-experience/"><div class="py-3 text-sm border-b border-solid font-fondamento">人生體驗與經驗<!-- --> <span class="font-color-gold-1">(<!-- -->33<!-- -->)</span></div></a><a class="link-unstyled" href="/categories/thinking-and-reflection/"><div class="py-3 text-sm border-b border-solid font-fondamento">想東想西日常故事<!-- --> <span class="font-color-gold-1">(<!-- -->5<!-- -->)</span></div></a></div></div><div><a href="/categories/language-learning/" class="blog-link-style"><div class="py-3 text-sm border-b border-solid font-fondamento">語言相關 LANGUAGE<!-- --> <span class="font-color-gold-1">(<!-- -->31<!-- -->)</span></div></a><div class="list-disc list-inside ml-4 text-gray-600"><a class="link-unstyled" href="/categories/experience-and-exam/"><div class="py-3 text-sm border-b border-solid font-fondamento">學習經驗與考試相關<!-- --> <span class="font-color-gold-1">(<!-- -->14<!-- -->)</span></div></a><a class="link-unstyled" href="/categories/toefl-prepare-plan/"><div class="py-3 text-sm border-b border-solid font-fondamento">托福準備紀錄<!-- --> <span class="font-color-gold-1">(<!-- -->17<!-- -->)</span></div></a></div></div><div><a href="/categories/travel-diary/" class="blog-link-style"><div class="py-3 text-sm border-b border-solid font-fondamento">旅行日記 Travel<!-- --> <span class="font-color-gold-1">(<!-- -->56<!-- -->)</span></div></a><div class="list-disc list-inside ml-4 text-gray-600"><a class="link-unstyled" href="/categories/japan/"><div class="py-3 text-sm border-b border-solid font-fondamento">日本－自由行旅記<!-- --> <span class="font-color-gold-1">(<!-- -->37<!-- -->)</span></div></a><a class="link-unstyled" href="/categories/taiwan/"><div class="py-3 text-sm border-b border-solid font-fondamento">台灣－蕃薯故鄉走跳<!-- --> <span class="font-color-gold-1">(<!-- -->5<!-- -->)</span></div></a><a class="link-unstyled" href="/categories/eu-europe/"><div class="py-3 text-sm border-b border-solid font-fondamento">歐洲－英國與冰島追逐幸福極光<!-- --> <span class="font-color-gold-1">(<!-- -->3<!-- -->)</span></div></a><a class="link-unstyled" href="/categories/us-america/"><div class="py-3 text-sm border-b border-solid font-fondamento">美國－賓州Juniata姐妹校與企業參訪<!-- --> <span class="font-color-gold-1">(<!-- -->11<!-- -->)</span></div></a></div></div><div class="mb-10 border border-solid py-4 mt-10"><p class="font-bold text-center text-gray grid-subtitle text-md">GALLERY</p></div></div></div></div></div></div></div></section><footer><div class="bg-white border-t border-solid"><div class="container px-5 mx-auto"><div class="xl:w-1/2 lg:w-3/4 w-full mx-auto text-center"><div class="text-gray-600 text-center text-xl font-hand-writing tracking-wider py-8 px-2">Hi, It&#x27;s Mina Yu, a software engineer, blogger and polyglot learner. Since 7-9 years ago, my dream is designing my own personal website and now I did it, I changed the website name to @Mina Influence, want to encourage people by my influence. I will continue to achieve more my dream in the future. I just want to tell you, no matter your plan looks how hard and how unachievable, Once you begin to do it, everything will be changed.</div></div></div></div><div class="bg-cyan-50 border-t border-solid"><div class="text-gray-300 text-center text-md motto-block py-8 px-4">Copy Right © 2024 @Mina Influence. Designed by MINA YU. Sign @MinaYu.</div></div></footer><script src="https://minayu.site/_next/static/chunks/webpack-7335b41bc6ef882c.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"https://minayu.site/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"https://minayu.site/_next/static/css/48a85a1880fd302d.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[4080,[\"185\",\"static/chunks/app/layout-e39bf6f0e9a90cbf.js\"],\"\"]\nb:I[6130,[],\"\"]\n7:[\"routes\",\"2021/09/miri-develop-technology-1-frontend-design-connect-backend-with-fastapi-line-bot-telegram-bot\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"https://minayu.site/_next/static/css/48a85a1880fd302d.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"fzrmfFo-YdKXgLNoo3Ymq\",\"assetPrefix\":\"https://minayu.site\",\"initialCanonicalUrl\":\"/2021/09/miri-develop-technology-1-frontend-design-connect-backend-with-fastapi-line-bot-telegram-bot/\",\"initialTree\":[\"\",{\"children\":[[\"routes\",\"2021/09/miri-develop-technology-1-frontend-design-connect-backend-with-fastapi-line-bot-telegram-bot\",\"c\"],{\"children\":[\"__PAGE__?{\\\"routes\\\":[\\\"2021\\\",\\\"09\\\",\\\"miri-develop-technology-1-frontend-design-connect-backend-with-fastapi-line-bot-telegram-bot\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"routes\",\"2021/09/miri-develop-technology-1-frontend-design-connect-backend-with-fastapi-line-bot-telegram-bot\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null],null]},[[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"$L9\",null,{\"src\":\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\",\"strategy\":\"afterInteractive\"}],[\"$\",\"$L9\",null,{\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-EETGWC7GNV\",\"strategy\":\"afterInteractive\"}],[\"$\",\"$L9\",null,{\"id\":\"ga4-init\",\"strategy\":\"afterInteractive\",\"children\":\"\\n            window.dataLayer = window.dataLayer || [];\\n            function gtag(){dataLayer.push(arguments);}\\n            gtag('js', new Date());\\n            gtag('config', 'G-EETGWC7GNV', {\\n              page_path: window.location.pathname,\\n            });\\n          \"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":null}]}]]}],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"[產品使用技術][Python] Miri的前端與後端接口、整體程式架構介紹 | FastApi x Line Bot x Telegram Bot | 開發概念系列(1) - 月水瓶 @Mina 的人生實驗室\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"在2021年2月離職後，我用了半年的時間用Python開發自己的占卜機器人作品，在這版本的開發有很大幅度的變動，我將原本的Flask框架改為FastApi，由原本只有Line Bot平台，新增Telegram的平台，無論是程式開發還是這篇文章都是自己綜合實力、努力、堅強跟嘗試的心血，它帶給我很多心靈上跟實力上的進步，現在我就來分享這半年實作技術方面的點點滴滴。\"}],[\"$\",\"meta\",\"4\",{\"name\":\"application-name\",\"content\":\"月水瓶 @Mina 的人生實驗室\"}],[\"$\",\"meta\",\"5\",{\"name\":\"author\",\"content\":\"minayu416\"}],[\"$\",\"link\",\"6\",{\"rel\":\"author\",\"href\":\"https://minayu.site\"}],[\"$\",\"meta\",\"7\",{\"name\":\"author\",\"content\":\"@Mina Influence\"}],[\"$\",\"meta\",\"8\",{\"name\":\"generator\",\"content\":\"Next.js 14.2.5\"}],[\"$\",\"meta\",\"9\",{\"name\":\"keywords\",\"content\":\"python,fastapi,line bot,telegram bot,heroku\"}],[\"$\",\"meta\",\"10\",{\"name\":\"referrer\",\"content\":\"origin-when-cross-origin\"}],[\"$\",\"meta\",\"11\",{\"name\":\"creator\",\"content\":\"minayu416\"}],[\"$\",\"meta\",\"12\",{\"name\":\"publisher\",\"content\":\"minayu416\"}],[\"$\",\"meta\",\"13\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"14\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"15\",{\"rel\":\"canonical\",\"href\":\"https://minayu.site/2021/09/miri-develop-technology-1-frontend-design-connect-backend-with-fastapi-line-bot-telegram-bot/\"}],[\"$\",\"link\",\"16\",{\"rel\":\"alternate\",\"hrefLang\":\"zh-TW\",\"href\":\"https://minayu.site/2021/09/miri-develop-technology-1-frontend-design-connect-backend-with-fastapi-line-bot-telegram-bot/\"}],[\"$\",\"meta\",\"17\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"18\",{\"property\":\"og:title\",\"content\":\"[產品使用技術][Python] Miri的前端與後端接口、整體程式架構介紹 | FastApi x Line Bot x Telegram Bot | 開發概念系列(1)\"}],[\"$\",\"meta\",\"19\",{\"property\":\"og:description\",\"content\":\"在2021年2月離職後，我用了半年的時間用Python開發自己的占卜機器人作品，在這版本的開發有很大幅度的變動，我將原本的Flask框架改為FastApi，由原本只有Line Bot平台，新增Telegram的平台，無論是程式開發還是這篇文章都是自己綜合實力、努力、堅強跟嘗試的心血，它帶給我很多心靈上跟實力上的進步，現在我就來分享這半年實作技術方面的點點滴滴。\"}],[\"$\",\"meta\",\"20\",{\"property\":\"og:url\",\"content\":\"https://minayu.site/2021/09/miri-develop-technology-1-frontend-design-connect-backend-with-fastapi-line-bot-telegram-bot/\"}],[\"$\",\"meta\",\"21\",{\"property\":\"og:site_name\",\"content\":\"月水瓶 @Mina 的人生實驗室\"}],[\"$\",\"meta\",\"22\",{\"property\":\"og:locale\",\"content\":\"zh-TW\"}],[\"$\",\"meta\",\"23\",{\"property\":\"og:image\",\"content\":\"https://minayu0416.files.wordpress.com/2021/09//screen-shot-2021-09-06-at-4.55.08-pm.png\"}],[\"$\",\"meta\",\"24\",{\"property\":\"og:image:width\",\"content\":\"1200\"}],[\"$\",\"meta\",\"25\",{\"property\":\"og:image:height\",\"content\":\"630\"}],[\"$\",\"meta\",\"26\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"27\",{\"property\":\"article:published_time\",\"content\":\"2021-09-06T11:32:09.000Z\"}],[\"$\",\"meta\",\"28\",{\"property\":\"article:author\",\"content\":\"Mina Yu\"}],[\"$\",\"meta\",\"29\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"30\",{\"name\":\"twitter:site:id\",\"content\":\"@MingJungYU\"}],[\"$\",\"meta\",\"31\",{\"name\":\"twitter:creator\",\"content\":\"@MingJungYU\"}],[\"$\",\"meta\",\"32\",{\"name\":\"twitter:title\",\"content\":\"[產品使用技術][Python] Miri的前端與後端接口、整體程式架構介紹 | FastApi x Line Bot x Telegram Bot | 開發概念系列(1)\"}],[\"$\",\"meta\",\"33\",{\"name\":\"twitter:description\",\"content\":\"在2021年2月離職後，我用了半年的時間用Python開發自己的占卜機器人作品，在這版本的開發有很大幅度的變動，我將原本的Flask框架改為FastApi，由原本只有Line Bot平台，新增Telegram的平台，無論是程式開發還是這篇文章都是自己綜合實力、努力、堅強跟嘗試的心血，它帶給我很多心靈上跟實力上的進步，現在我就來分享這半年實作技術方面的點點滴滴。\"}],[\"$\",\"meta\",\"34\",{\"name\":\"twitter:image\",\"content\":\"https://minayu0416.files.wordpress.com/2021/09//screen-shot-2021-09-06-at-4.55.08-pm.png\"}],[\"$\",\"meta\",\"35\",{\"name\":\"twitter:image:alt\",\"content\":\"@Mina Influence Image\"}],[\"$\",\"link\",\"36\",{\"rel\":\"shortcut icon\",\"href\":\"/static/img/favicon.jpg\"}],[\"$\",\"link\",\"37\",{\"rel\":\"icon\",\"href\":\"/static/img/favicon.jpg\"}],[\"$\",\"link\",\"38\",{\"rel\":\"apple-touch-icon\",\"href\":\"/static/img/favicon.jpg\"}],[\"$\",\"meta\",\"39\",{\"name\":\"next-size-adjust\"}]]\n"])</script><script>self.__next_f.push([1,"4:null\n"])</script><script>self.__next_f.push([1,"d:I[619,[\"676\",\"static/chunks/870fdd6f-d8d8a996639eb86b.js\",\"168\",\"static/chunks/168-06c8f4fac5ec5c0f.js\",\"619\",\"static/chunks/619-4671ee34442d690f.js\",\"432\",\"static/chunks/app/%5B...routes%5D/page-ab50a535e409addd.js\"],\"Navbar\"]\ne:Tb4ed,"])</script><script>self.__next_f.push([1,"\u003cp\u003e由於本人健康問題，再加上這幾天有其他事情比較重要，還有就是一下把開發感想寫完，寫文章的靈感突然全無，所以跟技巧還有概念設計相關的文章就拖到了現在才有靈感撰寫。\u003c/p\u003e\n\u003cp\u003e再將近一週內心的沈澱後，我想應該可以好好的撰寫本系列的文章了，我應該會分成三到四篇來撰寫。\u003c/p\u003e\n\u003cp\u003e這篇主要介紹的是 Miri 的前端設計，以及和後端 API 接口的程式設計。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003e整篇文章非常的長，以下為整篇文章的目錄\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e目錄如下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e概念: 前端設計\u003c/li\u003e\n\u003cli\u003e重構: API 及後端整體架構設計\u003c/li\u003e\n\u003cli\u003e實作: 期望與模擬的後端 API 層架構實作\u003c/li\u003e\n\u003cli\u003e實作: FastApi (含 Heroku 部署程式碼)\u003c/li\u003e\n\u003cli\u003e實作: Line Bot\n\u003cul\u003e\n\u003cli\u003e事件 Event\u003c/li\u003e\n\u003cli\u003e訊息型別 Message Type\u003c/li\u003e\n\u003cli\u003e實作: Api \u0026#x26; handler\u003c/li\u003e\n\u003cli\u003e選單 Menu\u003c/li\u003e\n\u003cli\u003eLine Bot 的一些注意細節\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e實作: Telegram Bot\n\u003cul\u003e\n\u003cli\u003e訊息處理者 Handler\u003c/li\u003e\n\u003cli\u003eMessage Type 訊息型別\u003c/li\u003e\n\u003cli\u003e創建一個 Telegram Bot\u003c/li\u003e\n\u003cli\u003e實作 Api \u0026#x26; Handler\u003c/li\u003e\n\u003cli\u003eTelegram Bot 的一些注意細節\u003c/li\u003e\n\u003cli\u003e選單 Menu\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e困難克服: 訊息於不同平台的呈現方式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e那麼就開始吧！\u003c/p\u003e\n\u003ch1 id=\"概念-前端設計\"\u003e概念: 前端設計\u003c/h1\u003e\n\u003cp\u003eMiri 在之前跟第三版本的規劃中，是沒有要將前端獨立出來開發的計畫，因為本人當初還只是很菜鳥的後端工程師，連後端開發都吃力了，要怎麼去學習前端。所以從 Miri 剛開始出生時，我就是先是打算利用\u003ccode\u003eLine Bot Api\u003c/code\u003e的功能，讓 Line 代替前端的功能，使我能夠更專注的在開發後端，將 Miri 做成一個 Line 的聊天機器人。\u003c/p\u003e\n\u003cp\u003e但是，在規劃第三版本時，我希望能夠朝向更國際化的市場前進，說白了一點就是希望能找國外的工作，讓外國的面試官看到這個作品，所以想要新增其他新的 Bot 平台，畢竟 Line 目前還是在東亞洲地區比較興盛，除此之外的地區都不是 Line 的主要地盤，所以若是要開發一個面向英文使用者的平台，就要另外找其他通訊軟體的 Bot 功能。\u003c/p\u003e\n\u003cp\u003e最一開始我有想過\u003ccode\u003eWhat's App\u003c/code\u003e 跟 \u003ccode\u003eFacebook 的 Messenger\u003c/code\u003e，但經過研究跟實際實作時，我發現要開發起來十分困難，會有些障礙，而且比較難克服。在一個外國朋友的推薦下，後來選擇了\u003ccode\u003eTelegram\u003c/code\u003e當作第二個可以連接到 Miri 的平台。\u003c/p\u003e\n\u003cp\u003e仔細看了 \u003ccode\u003eTelegram Bot Api\u003c/code\u003e後，發現他有和\u003ccode\u003eLine Bot Api\u003c/code\u003e相似的功能，也許在圖像化或者前端畫面豐富性沒有像 Line 那樣的齊全，但作為 Miri 另外一個連接的 Bot 平台，功能也夠了。\u003c/p\u003e\n\u003cp\u003e(才怪，我當初可是擔心死了，害怕在 Line 上能呈現的效果，在 Telegram 上到底要怎麼呈現 qq)\u003c/p\u003e\n\u003ch1 id=\"重構-後端及-api-架構設計\"\u003e重構: 後端及 API 架構設計\u003c/h1\u003e\n\u003cp\u003e有了要接兩個不同前端的平台的邏輯後，後端的程式架構就必須得做一些改變，我們先來看看第二版以前的 Miri 程式架構。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://minayu0416.files.wordpress.com/2021/09/screen-shot-2021-09-06-at-4.42.38-pm.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e在第二版以及之前的架構中，由於本身還只是年幼的後端工程師，再加上所經歷的專案跟產品經驗不多，也沒有單獨設計程式架構的經驗，所以在當時連 Api 是什麼都很吃力理解的狀態下，硬是兜了簡單的架構。(就是隨便做)\u003c/p\u003e\n\u003cp\u003e從圖中可以看到的是第二版是使用\u003ccode\u003eFlask\u003c/code\u003e的框架來實作，而由於當初的前端平台只有 Line，所以就把 \u003ccode\u003eFlask\u003c/code\u003e 跟 \u003ccode\u003eLine\u003c/code\u003e 的程式碼混在一起。\u003c/p\u003e\n\u003cp\u003e後端功能上非常簡單，當初並沒有需要紀錄帳號的功能，也沒有像現在這樣需要不同平台，所以基本上 Line 接收進來的訊息，直接丟進\u003ccode\u003eNLTK\u003c/code\u003e或\u003ccode\u003eJieba\u003c/code\u003e切詞後，去功能面簡單撈一下回答就把回覆送回給客戶端。\u003c/p\u003e\n\u003cp\u003e那麼看一下第三版的程式架構圖\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://minayu0416.files.wordpress.com/2021/09/screen-shot-2021-09-06-at-4.55.08-pm.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e比起上一個版本，由於要串接兩個不同的平台，所以在後端 API 中勢必得將不同平台的 API 入口分割開來，如圖中的架構，當然也因為為了相容兩種不同平台而做出的重構，在未來若有規劃想要開發出獨立的前端像是\u003ccode\u003e前端網頁\u003c/code\u003e或者\u003ccode\u003eapp mobile行動端\u003c/code\u003e都可以相容，而不用再做出這麼大幅度的更動。\u003c/p\u003e\n\u003cp\u003e再來還有一個很重要的點就是，由於目前是有兩種不同的平台而來的訊息，收到的訊息模式跟型別也會不同，在規劃上會特地多一個 \u003ccode\u003eprocess\u003c/code\u003e的步驟，主要是用來處理\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e將收到訊息統一處理為另外一種訊息物件可以不分平台差異傳送到後面的\u003ccode\u003e功能層面\u003c/code\u003e 取得回覆\u003c/li\u003e\n\u003cli\u003e將從\u003ccode\u003e功能層面\u003c/code\u003e取到的回覆傳回指定平台的\u003ccode\u003eprocess\u003c/code\u003e處理成可以傳回客戶端的訊息模板/型態\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e這是後端其中一個比較大幅度需要更改的重構部分。\u003c/p\u003e\n\u003cp\u003e而另外一個部分則是\u003ccode\u003e功能層面\u003c/code\u003e，因為 Miri 在第三版本確定會往\u003ccode\u003e命理跟占卜\u003c/code\u003e方向前進，所以比較大的主題功能會落於\u003ccode\u003e命理及占卜\u003c/code\u003e，把這個部分作為主要功能，而另外一個\u003ccode\u003e溝通功能\u003c/code\u003e則是保留若未來需要類似\u003ccode\u003e聊天/溝通\u003c/code\u003e的功能，還可以在這塊規劃的地區做開發。\u003c/p\u003e\n\u003cp\u003e主要主題是\u003ccode\u003e命理跟占卜\u003c/code\u003e，所以基本上功能面就是依照這個主題去展開程式架構，然後由每個功能去單獨和資料庫互動取出需要的資訊，詳細情形就不多說。\u003c/p\u003e\n\u003cp\u003e還有一個功能在圖中沒有呈現，就是關於\u003ccode\u003e系統層面\u003c/code\u003e的功能，像是\u003ccode\u003e帳號管理\u003c/code\u003e、\u003ccode\u003e使用者引導\u003c/code\u003e跟\u003ccode\u003e切換語言\u003c/code\u003e等其他功能，也會一併規劃在\u003ccode\u003e功能層面\u003c/code\u003e。\u003c/p\u003e\n\u003ch1 id=\"實作-期望與模擬的後端-api-層架構實作\"\u003e實作: 期望與模擬的後端 API 層架構實作\u003c/h1\u003e\n\u003cp\u003e我的程式碼沒有公開，也不會在部落格撰寫具體是怎麼實作，所以我設計了一個貼近真實實作的程式碼架構模擬，Miri 內部大致上也是照著這樣去實作的。\u003c/p\u003e\n\u003cp\u003e接下來的部分就是實作後端 API 層架構層，那麼期望的實作架構與程式碼如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eMiri\n├── api\n│   ├── line\n│   │   ├── __init__.py\n│   │   └── process.py\n│   └── telegram\n|       ├── __init__.py\n│       └── process.py\n│\n├── features\n│   ├── divination\n│   │   └── ?\n│   ├── conversation\n│   │   └── ?\n│   └── system\n│       └── ?\n│\n└── Procfile\n└── main.py\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e規劃上會將\u003ccode\u003eFastApi\u003c/code\u003e的程式碼實作在 \u003ccode\u003emain.py\u003c/code\u003e 作為 Api 接口的大門，然後 line 跟 telegram 會分開放在\u003ccode\u003eapi\u003c/code\u003e資料夾中，分別將 Api 程式碼寫在各自資料夾的\u003ccode\u003e__init__.py\u003c/code\u003e中，在用\u003ccode\u003eFastApi\u003c/code\u003e的\u003ccode\u003erounter\u003c/code\u003e功能將分開在不同檔案的 Api 路徑註冊進 api 的名單中，這樣即便 api 路徑在不同檔案，也能一併成為接口，接收 request 啦！\u003c/p\u003e\n\u003ch1 id=\"實作-fastapi\"\u003e實作: FastApi\u003c/h1\u003e\n\u003cp\u003e這個部分要換成\u003ccode\u003eFlask\u003c/code\u003e還是\u003ccode\u003eDjango\u003c/code\u003e或者其他的 WebApi 套件都可以，基本上會使用 FastApi 主要只是因為要離職時同事跟我說過這是目前最快的 Api 套件，基於好奇，就直接拿來使用在 Miri 身上，但我目前在 Miri 身上使用到 FastApi 功能沒有很多，所以就算之後要替換成其他 WebApi 套件，也很簡單。\u003c/p\u003e\n\u003cp\u003e在專案的根部底層創立\u003ccode\u003emain.py\u003c/code\u003e成為整個程式驅動的主程式，也就是說當架設於伺服器上時，只要跑\u003ccode\u003emain.py\u003c/code\u003e就能將整個程式跑起來，將 api 架起來，前端就能使用了\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003emain.py\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003eimport uvicorn\nfrom fastapi import FastAPI\n\nfrom api import line, telegram\n\napp = FastAPI()\n\napp.include_router(line.line_api)\napp.include_router(telegram.telegram_api)\n\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n\n# Production Setting\n# Run on Heroku/ Procfile, run terminal directly\n# web: uvicorn main:app --host=0.0.0.0 --port=${PORT:-5000}\n\n# Development Setting\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000)\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e原則上和 Flask 用法很像，先初始化一個\u003ccode\u003eapp\u003c/code\u003e，而這個\u003ccode\u003eapp\u003c/code\u003e就是代表整個程式及 api 的出入口，然後是將之後會寫在 line 跟 telegram 的 api 路徑註冊進\u003ccode\u003eapp\u003c/code\u003e中，這樣即便 api 沒有寫在主程式，但也會自動將處在不同資料夾的 api 列進能使用的 api。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003e# 初始化一個app，代表整個專案程式的web入口\napp = FastAPI()\n\n# 將分散在line跟telegram的 api rounte 註冊進app\napp.include_router(line.line_api)\napp.include_router(telegram.telegram_api)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再來寫了一個\u003ccode\u003ehello_world\u003c/code\u003e來測試架起來後可否呼叫到 api，接著是當正在撰寫程式碼時，需要開啟 debug 模式所寫的設定。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003e@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n\n# Production Setting\n# Run on Heroku/ Procfile, run terminal directly\n# web: uvicorn main:app --host=0.0.0.0 --port=${PORT:-5000}\n\n# Development Setting\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000)\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e最後要提及一下，之後怎麼部署於 \u003ccode\u003eHeroku\u003c/code\u003e 伺服器上，當所有程式都完成了，要部署於 Heroku 上時，需要把用於開發真錯的程式暫時註解掉。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003e# Development Setting\n# if __name__ == \"__main__\":\n#     uvicorn.run(app, host=\"127.0.0.1\", port=8000)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e接著需要在根部底層創一個 \u003ccode\u003eProcfile\u003c/code\u003e 檔，是部署 Heroku 時，會使用到的部署檔，沒有副檔名！！\u003c/p\u003e\n\u003cp\u003e接著直接將一行程式貼進\u003ccode\u003eProcfile\u003c/code\u003e就好\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eProcfile\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eweb: uvicorn main:app --host=0.0.0.0 --port=${PORT:-5000}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 Heroku 中，是將程式執行於 \u003ccode\u003e0.0.0.0\u003c/code\u003e 並非 \u003ccode\u003e127.0.0.1\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e之後使用 Github 連接自動部署就能自動將 FastApi 執行起來。\u003c/p\u003e\n\u003cp\u003eFastApi 的部分就到這為止，我並沒有使用太多功能，只是拿來當 web api 的大門接口而已\u003c/p\u003e\n\u003ch1 id=\"實作-line-bot\"\u003e實作: Line Bot\u003c/h1\u003e\n\u003cp\u003e再來進到 Line Bot Api 中，我一直在想要怎麼撰寫 Line 跟 Telegram 的教學會比較好，因為其實網路上已經蠻多人撰寫這方面的文章。\u003c/p\u003e\n\u003cp\u003e但我還是根據自己使用到的功能，加上一些開發需要注意的地方來撰寫此篇幅。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://minayu0416.files.wordpress.com/2021/09/screen-shot-2021-09-06-at-7.23.10-pm.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e這個是我自己畫的架構圖，基本上最左邊是 FastApi 的 api 大門，而 line 的 api 只有一個，就自訂吧，我這邊是定為\u003ccode\u003e/api/line/callback\u003c/code\u003e。可能會想問，如果 Line 的\u003ccode\u003eapi\u003c/code\u003e只有一個，那要怎麼分辨不同的訊息？這個時候\u003ccode\u003e事件Event\u003c/code\u003e跟\u003ccode\u003e訊息型別MessageType\u003c/code\u003e就很重要了。在 Line 中即便 api rounte 路徑只有一個，但主要是依靠訊息的\u003ccode\u003e事件Event\u003c/code\u003e跟\u003ccode\u003e訊息型別MessageType\u003c/code\u003e來接收跟回覆不同的訊息。\u003c/p\u003e\n\u003ch2 id=\"事件-event\"\u003e事件 Event\u003c/h2\u003e\n\u003cp\u003eEvent 是比訊息還上一層的概念，我們來看看 Line 中有哪些事件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMessageEvent\u003c/li\u003e\n\u003cli\u003eFollowEvent\u003c/li\u003e\n\u003cli\u003eUnfollowEvent\u003c/li\u003e\n\u003cli\u003eJoinEvent\u003c/li\u003e\n\u003cli\u003ePostbackEvent\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e還有一些我沒寫上去，基本上 Event 比較像是\u003ccode\u003e加入群組\u003c/code\u003e, \u003ccode\u003e離開群組\u003c/code\u003e, \u003ccode\u003e訊息動作\u003c/code\u003e或其他類似的動作，也就是說一種\u003ccode\u003eEvent\u003c/code\u003e需要一個或多個\u003ccode\u003ehandler\u003c/code\u003e處理程式去處理它，如果你要做的 Event 或者接收到的 Event 沒有特別寫 handler 來處理的話，後端程式也就不會接收到傳過來的 Event 事件，訊息就會卡在 api 層然後報錯。\u003c/p\u003e\n\u003cp\u003e而我基本上只用到兩個 Event: \u003ccode\u003eMessageEvent\u003c/code\u003e, \u003ccode\u003ePostbackEvent\u003c/code\u003e，所以只寫了 3 個 handler:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMessageEvent, message=TextMessage\u003c/li\u003e\n\u003cli\u003eMessageEvent, message=StickerMessage\u003c/li\u003e\n\u003cli\u003ePostbackEvent\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e剛剛有提到一個 Event 需要\u003ccode\u003e一個或多個\u003c/code\u003ehandler，主要就是在於\u003ccode\u003eMessageEvent\u003c/code\u003e能有不同的\u003ccode\u003e訊息型別Message Type\u003c/code\u003e，而每個訊息模式也都需要有一個 handler 來處理。\u003c/p\u003e\n\u003ch2 id=\"訊息型別-message-type\"\u003e訊息型別 Message Type\u003c/h2\u003e\n\u003cp\u003eLine 的訊息型別蠻多種的，詳細的型別給大家列在下方\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://developers.line.biz/en/docs/messaging-api/message-types/\"\u003eMessage types\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e基本上，從 Api 最開始收到的會是一種 Line 的訊息型別(Message Type)，\u003cstrong\u003e而當程式要回傳給 Line 客戶端時，也必須要將訊息包裝成 Line 的 Message Type，才能回傳給客戶端。\u003c/strong\u003e 所以就是一律用 Line 的 Message 物件去做溝通傳遞，也請放心即便傳來的是\u003ccode\u003eMessage物件\u003c/code\u003e，裡面也一定夾帶一堆參數，可以讀取其中的訊息或檔案。\u003c/p\u003e\n\u003cp\u003e在 Miri 當中，我大量的使用 \u003ccode\u003eTextMessage\u003c/code\u003e 跟 \u003ccode\u003eTemplate message\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eTextMessage\u003c/code\u003e指的是文字訊息，所以如果只要發文字訊息的話，只要將字串包成\u003ccode\u003eTextMessage\u003c/code\u003e物件再發出去就可以了\u003c/p\u003e\n\u003cp\u003e而\u003ccode\u003eTemplate message\u003c/code\u003e中，我在實作占卜流程時大量運用到了：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://developers.line.biz/en/docs/messaging-api/message-types/#buttons-template\"\u003eButtons template\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developers.line.biz/en/docs/messaging-api/message-types/#carousel-template\"\u003eCarousel template\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e這兩個訊息點擊按鈕後觸發的事件叫做\u003ccode\u003ePostbackEvent\u003c/code\u003e，所以如果有需要用到\u003ccode\u003eTemplate message\u003c/code\u003e來回覆訊息的話，記得加上\u003ccode\u003ePostbackEvent\u003c/code\u003e的 handler 來處理使用者按下按鈕之後的操作。\u003c/p\u003e\n\u003cp\u003e總之 Line Bot 也是一門有趣的學問，我可能只用到了 20-30%Line Bot 的功能來實作 Miri 的前端，有興趣的人可以多加鑽研，而我的文章也沒有說撰寫的很詳細，因為主要是紀錄 Miri 使用了哪些功能，不過只要有架構圖跟 api 的實作做完後，基本上後續的施工就依照每個人需求不同的功能各自去研究。\u003c/p\u003e\n\u003ch2 id=\"實作-api--handler\"\u003e實作: Api \u0026#x26; handler\u003c/h2\u003e\n\u003cp\u003e以上講了很多，接下來就實作 api 的部分，來看一下上面的架構圖\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eMiri\n├── api\n│   ├── line\n│   │   ├── __init__.py\n│   │   └── process.py\n│   └── telegram\n|       ├── __init__.py\n│       └── process.py\n...\n...\n└── Procfile\n└── main.py\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e先前已經將 FastApi 實作於\u003ccode\u003emain.py\u003c/code\u003e，這次要將 Line Api 實作於 \u003ccode\u003e./api/line/__init__.py\u003c/code\u003e 當中\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e./api/line/__init__.py\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003eimport configparser\nfrom datetime import datetime\n\nfrom fastapi import APIRouter, HTTPException, Request\n\nfrom linebot.models import *\n\nfrom linebot import (\n    LineBotApi, WebhookHandler\n)\nfrom linebot.exceptions import (\n    InvalidSignatureError\n)\n\nfrom log import logger\nfrom process import processor, MsgEvent\n\n\n# Load data from config.ini file\n# 通常重要資訊不會寫死在程式碼，會用環境變數檔存著，所以用此套件讀取出重要資訊\nconfig = configparser.ConfigParser()\nconfig.read('config.ini')\n\n# Access Token 跟 Secret 要去Line網頁中，你創的頻道內的設定觀看\n# Channel Access Token\nline_bot_api = LineBotApi(config['LINE']['ACCESS_TOKEN'])\n\n# Channel Secret\nhandler = WebhookHandler(config['LINE']['CHANNEL_SECRET'])\n\n# 這個部分就是開一個FastApi的Router，所有使用Router的Api Url都會註冊成為可以使用的api\nline_api = APIRouter()\n\n# 將 /api/line/callback 註冊進 line_api Router內\n# 主要的api入口，接收所有的request\n@line_api.post(\"/api/line/callback\")\nasync def callback(request: Request):\n\n    # get X-Line-Signature header value\n    # 這個部分是要從header取得Line特有的參數或簽名參數，需要和Line官方比對，有誤就會報錯\n    signature = request.headers['X-Line-Signature']\n\n    # get request body as text\n    body = await request.body()\n    body = body.decode('utf-8', 'replace')\n\n    # 這是我寫的logger, 可以刪除\n    logger().debug(\"Request body: \" + body)\n\n    # handle webhook body\n    # 透過接收到的訊息類型來分配到要進入哪個handler\n    try:\n        handler.handle(body, signature)\n\n    except Exception as e:\n        logger().error(\"ERROR: \" + str(e))\n\n    except InvalidSignatureError:\n        HTTPException(400)\n    return 'OK'\n\n\n# 處理文字訊息\n@handler.add(MessageEvent, message=TextMessage)\ndef handle_message(event):\n    \"\"\"\n    TextSendMessage(text = type(str))\n    \"\"\"\n\n    # 基本上各項元素都包在Event物件中\n    user_id = event.source.user_id\n    user_type = event.source.type\n    send_time = datetime.fromtimestamp(event.timestamp / 1000)\n    msg_type = event.message.type\n    message = event.message.text\n\n    # 這個我寫的，主要是因為我需要將傳來的事件統一變成另外一個我自己寫的物件，方便和後端溝通\n    msg_event = MsgEvent(\"line\", user_type, user_id, send_time, msg_type, message)\n    response = processor.analyze(msg_event)\n\n    # logger 也是我寫的\n    logger().debug(\"Reply response: \" + str(response))\n\n    # 這一步就是回覆給客戶端，注意response 是 list型別\n    line_bot_api.reply_message(event.reply_token, response)\n\n\n# 處理貼圖訊息\n@handler.add(MessageEvent, message=StickerMessage)\ndef handle_message(event):\n    import random\n    # 貼圖的部分沒怎麼做，就是從1-21個表情包隨便選一個回覆，使用者傳貼圖，我也回傳貼圖\n    message = StickerSendMessage(\n        package_id='1',\n        sticker_id='{}'.format(random.randint(1, 21))\n    )\n    logger().debug(\"Reply response: \" + str(message))\n    line_bot_api.reply_message(event.reply_token, message)\n\n\n@handler.add(PostbackEvent)\ndef handle_message(event):\n    import json\n    # 基本上 Template Message 傳出去前先要將每個按鈕的訊息壓成json\n    # 所以Postback回傳的訊息會是json\n    data = event.postback.data\n    data = json.loads(data)\n    user_id = event.source.user_id\n    user_type = event.source.type\n    send_time = datetime.fromtimestamp(event.timestamp / 1000)\n\n    # 處理訊息的部分，你可以替換成任何你想怎麼處理訊息就怎麼處理訊息\n    msg_event = MsgEvent(\"line\", user_type, user_id, send_time, \"option\", data)\n    response = msg_processor.analyze(msg_event)\n\n    # 自己寫的logger\n    logger().debug(\"Reply response: \" + str(response))\n\n    # 回覆給客戶端，注意response 是 list型別\n    line_bot_api.reply_message(event.reply_token, response)\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e很長一段，但大部分的步驟都有寫上註解了，將幾個比較重要的地方寫出來。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eLine 的 Access Token 跟 Secret\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e這兩個 Token 能夠在你在 Line 網頁上管理機器人的頁面設定中找到，建議最好不要寫死在程式碼中，最好是使用類似\u003ccode\u003e.ini\u003c/code\u003e,\u003ccode\u003e.config\u003c/code\u003e,\u003ccode\u003e.env\u003c/code\u003e之類的隱藏檔案做開發，或者加密儲存在資料庫，因為當這兩個 token 被偷走後，機器人頻道就等於整個被偷走。\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eAPIRouter\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e記得在實作 Line api 接口時，要創建 FastApi 的 router，我們用 code 展現一下\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eline/\u003cstrong\u003einit\u003c/strong\u003e.py\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003efrom fastapi import APIRouter\n\n# 我們在Line的api檔案中開一個FastApi的Router，用來將api串進fastapi接口，使其可使用\nline_api = APIRouter()\n\n# 將 /api/line/callback 註冊進 line_api Router內\n@line_api.post(\"/api/line/callback\")\nasync def callback(request: Request):\n    pass\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e接著回到先前就已經實作過的 FastApi \u003ccode\u003emain.py\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003efrom api import line, telegram\n\napp = FastAPI()\n\n# 可以看到我們將上面在line檔案中實作的api rounter註冊進app中，使其可以使用\napp.include_router(line.line_api)\n\n# Telegram 也是一樣的道理\napp.include_router(telegram.telegram_api)\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003ehandler \u0026#x26; event\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e根據上方程式碼，我們可以看到我寫了三個 handler\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003e\n# 處理文字訊息\n@handler.add(MessageEvent, message=TextMessage)\ndef handle_message(event):\n    \"\"\"\n    TextSendMessage(text = type(str))\n    \"\"\"\n\n    # 基本上各項元素都包在Event物件中\n    user_id = event.source.user_id\n    user_type = event.source.type\n    send_time = datetime.fromtimestamp(event.timestamp / 1000)\n    msg_type = event.message.type\n    message = event.message.text\n\n    # TODO 看你怎麼處理他囉！但是要記得response要是list型別\n    response = processor.analyze(msg_event)\n\n    # 這一步就是回覆給客戶端，注意response 是 list型別\n    line_bot_api.reply_message(event.reply_token, response)\n\n\n# 處理貼圖訊息\n@handler.add(MessageEvent, message=StickerMessage)\ndef handle_message(event):\n    # TODO 處理\n    line_bot_api.reply_message(event.reply_token, message)\n\n\n@handler.add(PostbackEvent)\ndef handle_message(event):\n    # 處理\n    line_bot_api.reply_message(event.reply_token, response)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在每一個處理的函式中，你需要用裝飾器 decorator 來標示這個函式是一個 Line 訊息的 handler，接著要在 handler 的參數中標明這個 handler 是要處理什麼事件/訊息。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003e@handler.add(MessageEvent, message=TextMessage)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e這個部分是回覆訊息，程式處理完的回覆記得將他依照需求變成 Line Message 物件，然後放進 list 中\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003eline_bot_api.reply_message(event.reply_token, response)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e簡單來說 \u003ccode\u003eresponse = [message_obj, message_obj]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e接著，傳來的 event 會夾帶一些參數，大致上需要用到的參數都會有\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003edef handle_message(event):\n    # ---------------^ 就是這個傳來的event\n    pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e基本上傳來的事件參數可得知：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用者 ID\u003c/li\u003e\n\u003cli\u003e使用者型別, 私人或是群組\u003c/li\u003e\n\u003cli\u003e傳訊息的時間\u003c/li\u003e\n\u003cli\u003e訊息類別\u003c/li\u003e\n\u003cli\u003e訊息本身\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e這邊要特別說一件事是 Line 的時間，我研究很久，因為他既很像 timestamp，但是轉換過來的時間又不正確，Line 的文件是寫 \u003ccode\u003eUnix Time\u003c/code\u003e，我最後是將讀到的時間除以 1000 再將其從 timestamp 轉為 datetime 才取到正常時間，不過是 UTC 時間，所以台灣時間是\u003ccode\u003e+8小時\u003c/code\u003e，記得要+上 8 小時再使用它。\u003c/p\u003e\n\u003ch2 id=\"選單-menu\"\u003e選單 Menu\u003c/h2\u003e\n\u003cp\u003eLine 的選單有兩種方式可以做成\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLine 官方帳號管理網頁設定\u003c/li\u003e\n\u003cli\u003e透過 Line Bot Api 設定\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e很抱歉讓你們失望了，身為後端工程師！！！\u003c/p\u003e\n\u003cp\u003e我沒有使用 Line Bot Api 做成選單 XD，因為當時我給自己實作 Miri 的時間已經超過了，再加上我覺得看起來選單這個功能如果用 Line Bot Api 做，不熟，看不懂，感覺很難 XD，在 Deadline 大敵將至，我還是決定用第一個方式做哈哈！\u003c/p\u003e\n\u003cp\u003e這是我做的選單，也是現在 Miri 在用的，也有被我朋友砲轟說是要做多簡單，乾脆他幫我畫！\u003c/p\u003e\n\u003cp\u003e畫畫不是我的強項！！！我用 Mac 的 KeyNote 拉出了我覺得可以接受的選單頁面就好，總之功能先到位比較重要！\u003c/p\u003e\n\u003cp\u003e如果是用\u003ccode\u003eLine 官方帳號管理網頁設定\u003c/code\u003e來做選單就會比較簡單，請到 \u003cstrong\u003e\u003ca href=\"https://manager.line.biz/\"\u003eLine 官方帳號管理網頁\u003c/a\u003e\u003c/strong\u003e，登入後，選擇你之前創建的 Bot 帳號。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e主頁\u003c/code\u003e \u003e \u003ccode\u003e聊天室相關\u003c/code\u003e \u003e \u003ccode\u003e圖文選單\u003c/code\u003e，接著就能找到創建圖文選單的地方。\u003c/p\u003e\n\u003cp\u003e點選\u003ccode\u003e建立\u003c/code\u003e，建立新的選單，比較重要的就是版型，目前官方提供像是圖中這麼多種版型，就依照個人需求選擇\u003c/p\u003e\n\u003cp\u003e我先隨便選了一個版型，接著右邊就有對應版型的動作類型可以選擇，然後左邊的設定也能夠上傳照片\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://mingjungyu.files.wordpress.com/2021/09/screen-shot-2021-09-07-at-5.18.59-pm.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e按鈕動作\u003c/code\u003e提供了 6~7 種，但對我幫助比較大的只有文字，我還在妄想有沒有可能可以設定 CallBack 按鈕 qq，所以最後我做的選單只有按下去發送文字，然後 Miri 再根據文字去判斷要回送什麼訊息。\u003c/p\u003e\n\u003ch2 id=\"line-bot-的一些注意細節\"\u003eLine Bot 的一些注意細節\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e如果程式處理時間太久，會被 Line 判定超過時效，不會回覆使用者訊息\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e我常常會用 debug 模式去追我程式到底哪邊寫錯，有時候甚至會直接在錯誤的地方一步一步看傳遞的參數，結果就發現如果訊息太久沒有回給客戶端，Line 就會有時間到期的問題，而直接跳錯，不會回覆。\u003c/p\u003e\n\u003cp\u003e感覺這算 Line 比較嚴謹的地方，所以估計 Line Bot 後面的程式也不太適合拿來做大量的運算或者複雜的功能，目前沒測過最久能接受多久，但如果在 Debug 模式或者程式跑太久後報錯，可能就是反應時間超過 Line 定的時效囉！\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e可以一次回上限五個訊息\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e不管是 Line 還是 Telegram，回覆是使用 list 中可包含許多 Message 物件，所以代表可以回覆多個訊息，比方說小明對 Bot 丟了一個 \u003ccode\u003eHello\u003c/code\u003e，則機器人可以回說: \u003ccode\u003eHello 您好！\u003c/code\u003e, \u003ccode\u003e請問要選擇哪個食物？\u003c/code\u003e, \u003ccode\u003e食物的Carousel template message\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003eresponse = [msg, msg, msg]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上限是五個訊息，超過就會報錯！\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eTemplate Message 的字數問題\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e我承認！在開發時，我沒有好好看 api 文章 XD\u003c/p\u003e\n\u003cp\u003e要記得在開發 Template Message 相關的訊息型別時，參考一下 api 文件，因為他的每個參數都會有一些限制。\u003c/p\u003e\n\u003cp\u003e例如:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCarousel template 的 columns 最多只能放 10 個\u003c/li\u003e\n\u003cli\u003eButton template 的 button actions 最多只能放 4 個按鈕\u003c/li\u003e\n\u003cli\u003eButton template 的 title 最多只能 40 個字(40 個中文或日文字當標題應該完全足夠，慘的是英文字母，所以感覺 Line 不太適合給英文使用者開發 XD，因為我光要想辦法把英文要能詞達意又要限制在固定的字數中，花了很大的功夫)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e總之就是開發時或者規劃時多看一下 api 文件就是！\u003c/p\u003e\n\u003cp\u003e但最令人羨慕的是 Button 的 Postback action 竟然可以多達 300 個字！！等於在 action 中塞一個很長一串的 dictionary 或者 json 都沒事，這個部分在 Telegram 非常麻煩，因為 Telegram 的 postback 有限字數 XDD\u003c/p\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e訊息處理失敗了就重新從前端/Line 訊息平台重新發一次 Request\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e這個部分基本上沒什麼問題，就是如果在開發時反覆測試，每次都從 Line 聊天室發訊息來後端測試功能，如果失敗了就是 request 直接失效，那就再從 Line 聊天室再發一次訊息。\u003c/p\u003e\n\u003cp\u003e為什麼提到這點，主要是因為 ...\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003eTelegram 就算程式處理失敗了，發過的 Request 若沒有處理或回覆的話，短時間內將會一直流浪在網路上，直到你的程式寫好/修好之前，他都會不斷的是同一個 request 往程式的 api 發，不斷的發。\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003ch1 id=\"實作-telegram-bot\"\u003e實作: Telegram Bot\u003c/h1\u003e\n\u003cp\u003e接下來就來寫 Telegram Bot 的部分啦！\u003c/p\u003e\n\u003cp\u003eTelegram bot 是此次的新功能之一，我覺得它的 bot 機制和 Line 其實蠻相似的，所以實作邏輯不會有太大的問題，但訊息型別的精緻度會稍微比 Line 差一點點，還有一個特點是\u003ccode\u003ePostBack\u003c/code\u003e的\u003ccode\u003ecallback_data\u003c/code\u003e參數字數不能超過 64 個字，所以幾乎隨便塞一個 dictionary 進\u003ccode\u003ecallback_data\u003c/code\u003e，很快就爆了，方法我待會會在下面說。\u003c/p\u003e\n\u003cp\u003eTelegram Bot 說是和 Line Bot 相似也能說不太相似，總之邏輯都是 Bot，所以 Api 接口的寫法都蠻像的，但是深入核心的部分就會發現這兩種 Bot 會是呈現兩種完全不同的功能，倒也不是說不能整合，只是需要做一點轉換。\u003c/p\u003e\n\u003cp\u003e還有就是我發現我看不太懂 Telegram 的文件 XD\u003c/p\u003e\n\u003ch2 id=\"訊息處理者-handler\"\u003e訊息處理者 Handler\u003c/h2\u003e\n\u003cp\u003e和 Line 一樣，Telegram 也會有訊息 Handler，如果沒有撰寫函式處理相對應的動作或事件，Bot 也是一樣不會有反應。\u003c/p\u003e\n\u003cp\u003e這邊舉例兩個我用的 Handler:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMessageHandler: 顧名思義就是處理任何訊息的訊息\n\u003cul\u003e\n\u003cli\u003efilter.text\u003c/li\u003e\n\u003cli\u003efilter.audio\u003c/li\u003e\n\u003cli\u003efilter.command\u003c/li\u003e\n\u003cli\u003efilter.document\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCallbackQueryHandler: 處理任何透過按鈕觸發的 Callback 動作\n\u003cul\u003e\n\u003cli\u003ehandle_callback\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e這個概念跟 Line 很相似，\u003ccode\u003eMessageHandler\u003c/code\u003e是一個 \u003ccode\u003eHandler\u003c/code\u003e，但還是要特別標注他是處理哪種訊息，比方說 \u003ccode\u003efilter.text\u003c/code\u003e 專門處理文字，\u003ccode\u003efilter.audio\u003c/code\u003e專門處理音訊。\u003c/p\u003e\n\u003cp\u003e所以假設你要一個 Bot 處理\u003ccode\u003e文字\u003c/code\u003e，\u003ccode\u003e檔案\u003c/code\u003e，\u003ccode\u003e音訊\u003c/code\u003e，就變成要增加三個 Handler:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMessageHandler(Filters.text, handle_message)\u003c/li\u003e\n\u003cli\u003eMessageHandler(filter.document, handle_message)\u003c/li\u003e\n\u003cli\u003eMessageHandler(filter.audio, handle_message)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e詳細程式碼下面會寫\u003c/p\u003e\n\u003ch2 id=\"message-type-訊息型別\"\u003eMessage Type 訊息型別\u003c/h2\u003e\n\u003cp\u003e一些基本的訊息型別會有，包含\u003ccode\u003e文字\u003c/code\u003e，\u003ccode\u003e圖像\u003c/code\u003e，\u003ccode\u003e影片\u003c/code\u003e，還有一些其他的訊息型別\u003c/p\u003e\n\u003cp\u003e有興趣再麻煩參照 \u003cstrong\u003e\u003ca href=\"https://core.telegram.org/bots/api#available-types\"\u003eTelegram Bot Api 文件\u003c/a\u003e\u003c/strong\u003e 啦！\u003c/p\u003e\n\u003cp\u003e比較讓我燒腦的是 Telegram Bot 沒有像 Line 的 \u003ccode\u003eCarousel Template\u003c/code\u003e的訊息，有提供的是\u003ccode\u003eInlineKeyboardMarkup\u003c/code\u003e跟\u003ccode\u003eInlineKeyboardButton\u003c/code\u003e型別，來看一下他的效果為何？\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003e想不想來占卜一下？ 哈哈\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e總之\u003ccode\u003eInlineKeyboardMarkup\u003c/code\u003e跟\u003ccode\u003eInlineKeyboardButton\u003c/code\u003e 是擁有按鈕的訊息，上面那個照片中其實是兩個訊息: \u003ccode\u003ePhoto\u003c/code\u003e + (\u003ccode\u003eInlineKeyboardMarkup\u003c/code\u003e + \u003ccode\u003eInlineKeyboardButton\u003c/code\u003e)，所以真實的效果是沒有照片的，而圖片中的整組訊息就是我想出來可以代替 Line 的 Button Template 訊息呈現於 Telegram 的替代方案，這個部分下方會說明。\u003c/p\u003e\n\u003cp\u003e總之，也許有其他訊息型別更適合，但就待各位去官方文件挖寶了。\u003c/p\u003e\n\u003ch2 id=\"創建一個-telegram-bot\"\u003e創建一個 Telegram Bot\u003c/h2\u003e\n\u003cp\u003eTelegram Bot 的創建和 Line 有一點點不一樣，Telegram 沒有像 Line 一樣完整的官方帳號管理頁面，也許本來這兩個機器人面對的客群就不同，要創建 Telegram Bot 你需要先找到他爸爸！\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://t.me/BotFather\"\u003eBotFather\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e不是跟你開玩笑吧 XD\u003c/p\u003e\n\u003cp\u003e進去之後，BotFather 就會寄很多創建 Bot 相關的指令，創建 Bot 跟刪除 Bot 蠻簡單的，所以如果操作不當就刪掉重創吧！\u003c/p\u003e\n\u003cp\u003e從\u003ccode\u003e/newbot\u003c/code\u003e開始\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e先取名字\u003c/li\u003e\n\u003cli\u003e再取 username，他會像是唯一的\u003ccode\u003e@\u003c/code\u003e id\u003c/li\u003e\n\u003cli\u003e創建後，會給你一串 Token\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e比較需要注意的是 bot 的 username，就是類似 Bot 的 Id，用\u003ccode\u003e@\u003c/code\u003e包裝的 Id，這個名字一定要含\u003ccode\u003ebot\u003c/code\u003e，所以你可以取 \u003ccode\u003eTetrisBot\u003c/code\u003e 或 \u003ccode\u003etetris_bot\u003c/code\u003e 就看個人發揮，就是要有 bot 字在裡面。\u003c/p\u003e\n\u003cp\u003e然後那串 token 很重要，是未來需要連接 Bot 到後端程式所需要的 Token，丟了也可以透過 BotFather 再創建，不用擔心！\u003c/p\u003e\n\u003cp\u003e接下來就進入到實作 APi 的部分！\u003c/p\u003e\n\u003ch2 id=\"實作-api--handler-1\"\u003e實作 Api \u0026#x26; Handler\u003c/h2\u003e\n\u003cp\u003e接下來一樣進到實作的部分，來看一下上面的架構圖\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eMiri\n├── api\n│   ├── line\n│   │   ├── __init__.py\n│   │   └── process.py\n│   └── telegram\n|       ├── __init__.py\n│       └── process.py\n...\n...\n└── Procfile\n└── main.py\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e先前已經將 FastApi 實作於\u003ccode\u003emain.py\u003c/code\u003e，這次要將 Telegram Api 實作於 \u003ccode\u003e./api/telegram/__init__.py\u003c/code\u003e 當中\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e./api/telegram/__init__.py\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003eimport configparser\nfrom datetime import timedelta\n\nfrom fastapi import APIRouter, HTTPException, Request\n\nimport telegram\nfrom telegram import Update, Bot\nfrom telegram.ext import Dispatcher, MessageHandler, CallbackQueryHandler, Filters, CallbackContext\n\nfrom process import MsgEvent, processor\n\n\n# 建議將Token存入環境變數檔或者資料庫中\nconfig = configparser.ConfigParser()\nconfig.read('config.ini')\n\n# 一樣需要用FastApi的Router功能初始化telegram_api\ntelegram_api = APIRouter()\n\n# 還記得上面說的Token嗎？要寫在這邊\nbot = telegram.Bot(token=(config['TELEGRAM']['ACCESS_TOKEN']))\n\n# 這邊一樣，將 /api/telegram/hook 註冊於 rounter中\n@telegram_api.post('/api/telegram/hook')\nasync def webhook_handler(request: Request):\n    \"\"\"Set route /hook with POST method will trigger this method.\"\"\"\n    body = await request.json()\n\n    update = telegram.Update.de_json(body, bot)\n\n    # 需要將來的事件丟進handler\n    dispatcher.process_update(update)\n    return 'ok'\n\n\ndef handle_message(update: Update, context: CallbackContext):\n    \"\"\"Reply message.\"\"\"\n    text = update.message.text\n    user_id = update.message.chat.id\n    user_type = update.message.chat.type\n\n    send_time = update.message.date + timedelta(hours=8)\n\n    # 處理的部分\n    msg_event = MsgEvent(\"telegram\", user_type, user_id, send_time, \"text\", text)\n    response = msg_processor.analyze(msg_event)\n\n    # 這邊示範寄出照片跟文字訊息\n    bot.send_photo(update.message.chat_id, photo=response.photo)\n    bot.send_message(update.message.chat_id, response.text)\n\n\ndef handle_callback(update: Update, context: CallbackContext):\n    \"\"\"Reply message.\"\"\"\n    data = update.callback_query.data\n    user_id = update.callback_query.message.chat.id\n    user_type = update.callback_query.message.chat.type\n\n    send_time = update.callback_query.message.date + timedelta(hours=8)\n\n    # 處理的部分，請各位自由發揮\n    msg_event = MsgEvent(\"telegram\", user_type, user_id, send_time, \"option\", data)\n    response = msg_processor.analyze(msg_event)\n\n    # 這邊示範寄出照片跟文字訊息\n    bot.send_photo(update.callback_query.message.chat_id, photo=response.photo)\n    bot.send_message(update.callback_query.message.chat_id, response.text)\n\n\n# New a dispatcher for bot\ndispatcher = Dispatcher(bot, None)\n\n# 需要新增 Handler 來處理特定的訊息跟動作\ndispatcher.add_handler(MessageHandler(Filters.text, handle_message))\ndispatcher.add_handler(CallbackQueryHandler(handle_callback))\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e跟上方的 Line Api 實作方式很相似，幾個注意的要點，一樣提醒大家\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eTelegram token 建議使用 \u003ccode\u003econfig\u003c/code\u003e, \u003ccode\u003e.env\u003c/code\u003e檔案儲存或者存入資料庫\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e記得利用 token 初始化一個 telegram 的 bot，會需要使用 bot 做回覆訊息的功能\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003e# 還記得上面說的Token嗎？要寫在這邊，初始化你的Telegram Bot\nbot = telegram.Bot(token=(config['TELEGRAM']['ACCESS_TOKEN']))\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e記得要新增你想處理的訊息/動作的 Handler\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003e# 需要新增 Handler 來處理特定的訊息跟動作\ndispatcher.add_handler(MessageHandler(Filters.text, handle_message))\ndispatcher.add_handler(CallbackQueryHandler(handle_callback))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e以這個例子來說是處理 \u003ccode\u003e訊息動作\u003c/code\u003e 的 \u003ccode\u003e文字訊息\u003c/code\u003e跟 \u003ccode\u003eCallback動作\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMessageHandler(Filters.text, handle_message)\u003c/li\u003e\n\u003cli\u003eCallbackQueryHandler(handle_callback)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e所以假設你要處理客戶端傳來音訊，那就是以此類推：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMessageHandler(Filters.audio, handle_message)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e詳細情況再麻煩爬文 Python 的 \u003cstrong\u003e\u003ca href=\"https://github.com/python-telegram-bot/python-telegram-bot\"\u003eTelegram 套件\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e記得要將 Telegram 的 api route 透過 FastApi APIRouter 加入路徑\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003etelegram_api = APIRouter()\n\n@telegram_api.post('/api/telegram/hook')\nasync def webhook_handler(request: Request):\n    pass\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e注意由一般訊息來的參數跟從 callback 動作來的參數會在不同地方\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003e# 以取user_id為例\n\n# 一般訊息從update.message來\nuser_id = update.message.chat.id\n\n# Callback 的參數會在callback_query內\nuser_id = update.callback_query.message.chat.id\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e寄出去的訊息型別\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在 Telegram 中傳送文字訊息跟圖片不用特別轉換成另外一種訊息物件，寄圖片有寄圖片的函式\u003ccode\u003esend_photo\u003c/code\u003e，重送訊息也有傳送訊息的函式 \u003ccode\u003esend_message\u003c/code\u003e，只是參數中無論是 photo 還是 text 都要塞字串。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003ebot.send_photo(update.message.chat_id, photo=response.photo)\nbot.send_message(update.message.chat_id, response.text)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再來，我用的按鈕訊息，也是用\u003ccode\u003esend_message\u003c/code\u003e來發送訊息，唯一不同的是，需要多帶一個參數\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003e\n# 你需要用`InlineKeyboardMarkup`跟`InlineKeyboardButton`兩個物件做出你要的訊息模式，再帶入reply_markup中，所以資訊會長這樣\n\nmarkup =\nInlineKeyboardMarkup([\n    InlineKeyboardButton(\"button1\", \"{'action': push}\"),\n    InlineKeyboardButton(\"button2\", \"{'action': pull}\"),\n    InlineKeyboardButton(\"button3\", \"{'action': cut}\")\n])\n\nbot.send_message(chat_id, text, reply_markup=markup)\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e換你實作啦！\u003c/p\u003e\n\u003ch2 id=\"telegram-bot-的一些注意細節\"\u003eTelegram Bot 的一些注意細節\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eRequest 若沒得到回應，會一直重複對 api 發送\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e這點和 Line 不同，Telegram 的 Request 沒有短時效問題，所以如果 Request 沒有得到回覆（也就是可能在跑程式的某個地方報錯），那那個 Request 會一直循環在網路雲端中，然後不斷地往 api 發送直到取得答案為止，我有點忘記時效多少，但我記得好像...一天內失敗的 Request 都會活著。\u003c/p\u003e\n\u003cp\u003e如果不幸在測試程式時，發送 Request 太多失敗，那就 Debug 模式繼續開著等剛剛發送的 Request 會延遲幾秒後再次自動向 api 發送。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCallBack Data 參數有限制\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如果要用 \u003ccode\u003eInlineKeyboardButton\u003c/code\u003e當作按鈕做出 Callback 行為，要注意一下 \u003ccode\u003ecallback_data\u003c/code\u003e不能超過 64 的字，由於我是塞字典，所以一下就爆字數了，文件在此 \u003ca href=\"https://core.telegram.org/bots/api#inlinekeyboardbutton\"\u003eInlineKeyboardButton\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e我的參數：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003e# 隨隨便便寫的字典就48個字了\nInlineKeyboardButton(callback_data=str({\"category\": \"communication\", \"action\": \"flirt\"}))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e當然你也可以直接就寫文字，例如:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003e# 寫中文字完全OK\nInlineKeyboardButton(callback_data=str(\"會話，調情\"))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e看個人發揮，我個人是塞字典，比較好我後端程式後續的程式操作，但又很容易爆字！\u003c/p\u003e\n\u003cp\u003e所以我的一個作法是，我在 CallBack 訊息傳出去跟傳回來時做了一個\u003ccode\u003e壓縮器/加密器\u003c/code\u003e，將超過長度的 \u003ccode\u003ecallback_data\u003c/code\u003e透過演算法或加密法壓縮成 64 個字內，回來時再用一樣的方式解密，這樣就能夠解決 64 個字限制的問題！\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eInlineKeyboardButton 按鈕寬度跟排列\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在實作 Button 訊息時，老實說我也有遇到如果我的按鈕字數太長，他就會被遮住，比方說：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 例如這樣字就會被壓縮到！\n\n[Runes][Tarot][Leno..][Moon..]\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可是我希望字可以全部顯示，希望能夠將按鈕加寬。Telegram 沒能讓按鈕加寬，但可以透過按鈕的排列來使按鈕加寬，這邊給些例子參考\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 假設完整是這樣\nmarkup =\nInlineKeyboardMarkup([\n    InlineKeyboardButton(\"button1\", \"{'action': push}\"),\n    InlineKeyboardButton(\"button2\", \"{'action': pull}\"),\n    InlineKeyboardButton(\"button3\", \"{'action': cut}\")\n])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e\n# 我們將一些字簡略，比較好展示\n\nMarkup(\n    [Button(), Button()]\n)\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e\n# 我們將一些字簡略，比較好展示\n\nMarkup(\n    [\n        [Button()],\n        [Button()],\n        [Button()],\n        [Button()],\n        [Button()],\n        [Button()]\n        ]\n)\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e\n# 我們將一些字簡略，比較好展示\n\nMarkup(\n    [\n        [Button()],\n        [Button(), Button()],\n        [Button(), Button()],\n        ]\n)\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e簡單來說就是用 list 來去分割按鈕\u003c/strong\u003e\u003c/p\u003e\n\u003ch2 id=\"選單-menu-1\"\u003e選單 Menu\u003c/h2\u003e\n\u003cp\u003e再來也是 Telegram 的選單，Telegram 的選單基本上沒有像 Line 那樣的華麗，如圖，這是 Miri 的選單\u003c/p\u003e\n\u003cp\u003e蠻乾淨簡單的，是用 \u003ccode\u003e/command\u003c/code\u003e的動作作為選單按鈕，然後最一開始 Menu 會向上方圖一樣，在文字輸入匡左方會多一個 Menu，然後可以縮放跟展開。\u003c/p\u003e\n\u003cp\u003eMenu 的設定也是呼叫 機器人的爸爸 XD，\u003cstrong\u003e\u003ca href=\"https://t.me/BotFather\"\u003eBotFather\u003c/a\u003e\u003c/strong\u003e，來設定選單\u003c/p\u003e\n\u003cp\u003e在 Telegram 中不是 Set Menu，而是\u003ccode\u003esetcommands\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e格式如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecommand1 - Description\ncommand2 - Another description\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e你可以一次把要設定的 command 打齊一次送出去！\u003c/p\u003e\n\u003cp\u003e就有美美簡約的選單囉！\u003c/p\u003e\n\u003ch2 id=\"困難克服-訊息於不同平台的呈現方式\"\u003e困難克服: 訊息於不同平台的呈現方式\u003c/h2\u003e\n\u003cp\u003e在實作於 Line Bot 跟 Telegram Bot 遇到的一個困難是，由於這兩個後端是共用程式，所以期望上希望兩者呈現的功能要一致，簡單來說就是當點下\u003ccode\u003e占卜\u003c/code\u003e按鈕時，要跳出六個\u003ccode\u003e占卜方法\u003c/code\u003e，我希望是圖文並茂，這在 Line Bot 上，用\u003ccode\u003eCarousel message\u003c/code\u003e可以完美辦到:\u003c/p\u003e\n\u003cp\u003e但是在 Telegram 就不是這麼一回事了，因為 Telegram 沒有 \u003ccode\u003eCarousel message\u003c/code\u003e，所以在這個單元想來介紹一下，我是怎麼改動流程盡量讓兩邊平台訊息一致的。\u003c/p\u003e\n\u003cp\u003e首先是選單目錄，在 Line 使用\u003ccode\u003eCarousel message\u003c/code\u003e，在 Telegram 用\u003ccode\u003eInlineKeyboardMarkup\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003e可以往右滑\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003e在 Telegram 的呈現上會稍微遜色，畢竟沒有圖片輔佐\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e所以在規劃使用者流程時，我會特地讓 Line \u003ccode\u003eCarousel message\u003c/code\u003e變成像是\u003ccode\u003e列表\u003c/code\u003e的邏輯，當點進去單個項目，才是進到那個項目的動作，來展現一下\u003c/p\u003e\n\u003cp\u003e點選\u003ccode\u003eClick\u003c/code\u003e後，兩邊訊息會一致\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003eLine 點選後會進到 Button Message，用一個感覺多此一舉的步驟來緩和 Telegram 沒有辦法圖文兼具的窘境。\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003e接著我們來看一下 Telegram 方，使用了 Photo + InlineKeyboardMarkup 兩個訊息的 Combo 連發達成像 Line 的效果，緩和解決了沒有圖片的問題。\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e由於本人算是第一次做這種前端有兩個以上的平台，先前都是後端對到前端，我相信很多厲害的 app 或網站，兩者兼具的軟體都需要具備這種面對兩種平台以上的後端程式設計，而這是我第一次面對，所以難免在處理上會比較尷尬一點。\u003c/p\u003e\n\u003cp\u003e也許這也就能夠理解為什麼有些軟體有些功能在網頁上是沒有的，但是在 app 上有，也許就是因為沒辦法做到兩邊展現同樣的效果跟體驗，所以必須有一方是犧牲的。\u003c/p\u003e\n\u003cp\u003e這是我目前短暫想出的方式，也許會讓 Line 使用者在使用上有點多此一舉跟卡卡的感覺。期望未來如果我實作前端網頁跟 mobile 版本後，就不需要糾結於這個問題，但也有可能未來即便出了網頁跟手機端，還是會保留機器人版本(說不定喔！)\u003c/p\u003e\n\u003cp\u003e好啦，這篇應該是產品技術文章中最長的文章，能看到這邊的人也蠻厲害的了(還是只會有我看得到 XD)\u003c/p\u003e\n\u003cp\u003e多謝支持啦！\u003c/p\u003e"])</script><script>self.__next_f.push([1,"5:[[\"$\",\"header\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"max-auto\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto flex flex-wrap border-b border-solid\",\"children\":[[\"$\",\"div\",null,{\"className\":\"lg:w-1/2 w-full lg: h-full object-cover object-center bg-cover\",\"children\":[\"$\",\"div\",null,{\"className\":\"w-full h-full\",\"children\":[\"$\",\"div\",null,{\"className\":\"relative overflow-hidden\",\"children\":[[\"$\",\"img\",null,{\"className\":\"object-cover w-full brightness-75 h-[20rem]` md:h-[25rem]\",\"src\":\"/static/img/blog-cover-image.jpg\",\"alt\":\"Blog Cover Image\"}],[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Ld\",null,{}],[\"$\",\"div\",null,{\"className\":\"absolute px-2 py-2 site-branding h-[25rem]\",\"children\":[[\"$\",\"div\",null,{\"className\":\"site-title\",\"children\":[\"$\",\"p\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"/\",\"children\":\"@Mina Influence\"}]}]}],[\"$\",\"div\",null,{\"className\":\"site-description\",\"children\":[\"$\",\"p\",null,{\"children\":\"Inspire you to have New thinking, Walk out your unique Road.\"}]}]]}]]}]]}]}]}],[\"$\",\"div\",null,{\"className\":\"grid justify-items-center lg:w-1/2 w-full lg:h-auto lg:py-6 mt-6 lg:mt-0 hidden md:block\",\"children\":[\"$\",\"div\",null,{\"className\":\"blog-branding-intro motto-block\",\"children\":[\"$\",\"section\",null,{\"className\":\"text-gray-500 body-font\",\"children\":[\"$\",\"div\",null,{\"className\":\"container px-6 mx-auto\",\"children\":[\"$\",\"div\",null,{\"className\":\"w-full mx-auto text-center\",\"children\":[[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"fill\":\"currentColor\",\"className\":\"inline-block w-6 h-6 text-gray-400 mb-4\",\"viewBox\":\"0 0 975.036 975.036\",\"children\":[\"$\",\"path\",null,{\"d\":\"M925.036 57.197h-304c-27.6 0-50 22.4-50 50v304c0 27.601 22.4 50 50 50h145.5c-1.9 79.601-20.4 143.3-55.4 191.2-27.6 37.8-69.399 69.1-125.3 93.8-25.7 11.3-36.8 41.7-24.8 67.101l36 76c11.6 24.399 40.3 35.1 65.1 24.399 66.2-28.6 122.101-64.8 167.7-108.8 55.601-53.7 93.7-114.3 114.3-181.9 20.601-67.6 30.9-159.8 30.9-276.8v-239c0-27.599-22.401-50-50-50zM106.036 913.497c65.4-28.5 121-64.699 166.9-108.6 56.1-53.7 94.4-114.1 115-181.2 20.6-67.1 30.899-159.6 30.899-277.5v-239c0-27.6-22.399-50-50-50h-304c-27.6 0-50 22.4-50 50v304c0 27.601 22.4 50 50 50h145.5c-1.9 79.601-20.4 143.3-55.4 191.2-27.6 37.8-69.4 69.1-125.3 93.8-25.7 11.3-36.8 41.7-24.8 67.101l35.9 75.8c11.601 24.399 40.501 35.2 65.301 24.399z\"}]}],[\"$\",\"p\",null,{\"className\":\"leading-relaxed\",\"children\":\"有的時候，你無意間遇到的一些故事，會激發你的靈感，改變你的想法，接下來你會用與之前全然不同的觀念去創造屬於你獨特的故事。\"}],[\"$\",\"span\",null,{\"className\":\"inline-block h-1 w-10 rounded bg-pink-500 mt-8 mb-6\"}],[\"$\",\"h2\",null,{\"className\":\"text-gray-900 font-medium title-font tracking-wider text-lg\",\"children\":\"Sign @MinaYu.\"}]]}]}]}]}]}]]}]}]}],[\"$\",\"section\",null,{\"className\":\"text-gray-600 body-font\",\"children\":[\"$\",\"div\",null,{\"className\":\"container py-12 mx-auto\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex-wrap\",\"children\":[\"$\",\"div\",null,{\"className\":\"p-2\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto flex flex-wrap bg-white\",\"children\":[[\"$\",\"div\",null,{\"className\":\"lg:w-2/3 w-full lg: h-full object-cover object-center bg-cover\",\"children\":[\"$\",\"div\",null,{\"className\":\"px-4 mb-4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"mb-10 border border-solid py-4\",\"children\":[[\"$\",\"p\",null,{\"className\":\"text-center tracking-widest text-md font-medium post-category font-fondamento\",\"children\":\"軟體開發 SWD\"}],[\"$\",\"h3\",null,{\"className\":\"text-center tracking-widest text-md font-medium post-category font-fondamento\",\"children\":\"software-development\"}],[\"$\",\"p\",null,{\"className\":\"font-bold text-center text-gray grid-subtitle text-md font-fondamento px-4 pt-2 pb-2\",\"children\":\"[產品使用技術][Python] Miri的前端與後端接口、整體程式架構介紹 | FastApi x Line Bot x Telegram Bot | 開發概念系列(1)\"}],[\"$\",\"p\",null,{\"className\":\"text-center test-gray italic tracking-wider font-mario\",\"children\":[\"Posted on \",\"Sep\",\" \",6,\", \",2021]}]]}],[\"$\",\"div\",null,{\"className\":\"flex-wrap\",\"children\":[[\"$\",\"img\",null,{\"className\":\"h-full w-full object-cover object-center mb-6 border border-solid\",\"src\":\"https://minayu0416.files.wordpress.com/2021/09/screen-shot-2021-09-06-at-4.55.08-pm.png\",\"alt\":\"\"}],[\"$\",\"article\",null,{\"className\":\"prose prose-slate prose-lg md:prose-base max-w-none break-words whitespace-pre-wrap [\u0026_h1]:text-2xl [\u0026_h1]:mb-0 [\u0026_h2]:mb-0 [\u0026_h2]:text-xl [\u0026_p]:mt-2 [\u0026_p]:mb-2 [\u0026_li]:mt-1 [\u0026_li]:mb-1 [\u0026_li]:leading-snug [\u0026_ul]:mt-0 [\u0026_ul]:mb-0 [\u0026_ul]:leading-none\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}]]}]]}]}],[\"$\",\"div\",null,{\"className\":\"lg:w-1/3 w-full lg:h-auto lg: mt-6 lg:mt-0\",\"children\":[\"$\",\"div\",null,{\"className\":\"px-4\",\"children\":[[\"$\",\"div\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"mb-10 border border-solid py-4\",\"children\":[\"$\",\"p\",null,{\"className\":\"font-bold text-center text-gray grid-subtitle text-md\",\"children\":\"ABOUT ME\"}]}],[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center\",\"children\":[\"$\",\"img\",null,{\"className\":\"object-cover rounded-full\",\"width\":\"175\",\"height\":\"175\",\"src\":\"/static/img/logo.jpg\",\"alt\":\"Author Profile\"}]}],[\"$\",\"p\",null,{\"className\":\"leading-relaxed text-md text-center pt-3 pb-3 px-2 motto-block\",\"children\":\"嗨，我是Mina. 一個ENTP奇女子，時常可以隨手拈來創意的Idea，正向､ 活躍且浪漫。是軟體開發工程師､ 部落客，還是多語學習者，喜歡去探索不同的文化跟發明些東東。\"}],[\"$\",\"p\",null,{\"className\":\"leading-relaxed text-2xl text-center pt-1 pb-4 motto-block\",\"children\":\"@MinaYu Signed\"}],[\"$\",\"div\",null,{\"className\":\"border border-solid py-4\",\"children\":[\"$\",\"p\",null,{\"className\":\"font-bold text-center text-gray grid-subtitle text-md\",\"children\":\"BLOG STATS\"}]}],[\"$\",\"div\",null,{\"className\":\"my-5 pl-5 font-bold font-voll\",\"children\":[[\"$\",\"span\",null,{\"id\":\"busuanzi_container_site_pv\",\"children\":[\"$\",\"p\",null,{\"className\":\"pb-2\",\"children\":[\"Visits: \",[\"$\",\"span\",null,{\"id\":\"busuanzi_value_site_pv\"}]]}]}],[\"$\",\"span\",null,{\"id\":\"busuanzi_container_site_uv\",\"children\":[\"$\",\"p\",null,{\"children\":[\"Visitors: \",[\"$\",\"span\",null,{\"id\":\"busuanzi_value_site_uv\"}]]}]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"mb-5 border border-solid py-4\",\"children\":[\"$\",\"p\",null,{\"className\":\"font-bold text-center text-gray grid-subtitle text-md\",\"children\":\"CATEGORY\"}]}],[[\"$\",\"div\",\"software-development\",{\"children\":[[\"$\",\"a\",null,{\"href\":\"/categories/software-development/\",\"className\":\"blog-link-style\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"軟體開發 SWD\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",105,\")\"]}]]}]}],[\"$\",\"div\",null,{\"className\":\"list-disc list-inside ml-4 text-gray-600\",\"children\":[[\"$\",\"a\",\"building-diary-of-website-and-blog\",{\"className\":\"link-unstyled\",\"href\":\"/categories/building-diary-of-website-and-blog/\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"網頁與部落格的建築日記\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",22,\")\"]}]]}]}],[\"$\",\"a\",\"frontend-senior-training-plan\",{\"className\":\"link-unstyled\",\"href\":\"/categories/frontend-senior-training-plan/\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"[前端] 前端小菜鳥的成長計畫\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",11,\")\"]}]]}]}],[\"$\",\"a\",\"10000-hours-backend-senior-training-plan\",{\"className\":\"link-unstyled\",\"href\":\"/categories/10000-hours-backend-senior-training-plan/\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"[後端] 1萬小時 - 後端工程師養成計劃\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",39,\")\"]}]]}]}],[\"$\",\"a\",\"architectural-design-and-solutions\",{\"className\":\"link-unstyled\",\"href\":\"/categories/architectural-design-and-solutions/\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"架構設計與構思創新解決方案\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",10,\")\"]}]]}]}],[\"$\",\"a\",\"working-travel-diary\",{\"className\":\"link-unstyled\",\"href\":\"/categories/working-travel-diary/\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"工作旅行記\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",10,\")\"]}]]}]}],[\"$\",\"a\",\"crasy-master-paper\",{\"className\":\"link-unstyled\",\"href\":\"/categories/crasy-master-paper/\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"[專案] 碩論也瘋狂\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",13,\")\"]}]]}]}]]}]]}],[\"$\",\"div\",\"mysticism-and-numerology\",{\"children\":[[\"$\",\"a\",null,{\"href\":\"/categories/mysticism-and-numerology/\",\"className\":\"blog-link-style\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"神秘學與命理研究談\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",26,\")\"]}]]}]}],[\"$\",\"div\",null,{\"className\":\"list-disc list-inside ml-4 text-gray-600\",\"children\":[[\"$\",\"a\",\"divination\",{\"className\":\"link-unstyled\",\"href\":\"/categories/divination/\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"占卜\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",5,\")\"]}]]}]}],[\"$\",\"a\",\"temple-and-buddha\",{\"className\":\"link-unstyled\",\"href\":\"/categories/temple-and-buddha/\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"寺廟與佛\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",2,\")\"]}]]}]}],[\"$\",\"a\",\"mysticism\",{\"className\":\"link-unstyled\",\"href\":\"/categories/mysticism/\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"神秘學相關\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",6,\")\"]}]]}]}],[\"$\",\"a\",\"chart\",{\"className\":\"link-unstyled\",\"href\":\"/categories/chart/\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"命理學與命盤\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",13,\")\"]}]]}]}]]}]]}],[\"$\",\"div\",\"life\",{\"children\":[[\"$\",\"a\",null,{\"href\":\"/categories/life/\",\"className\":\"blog-link-style\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"日常生活\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",42,\")\"]}]]}]}],[\"$\",\"div\",null,{\"className\":\"list-disc list-inside ml-4 text-gray-600\",\"children\":[[\"$\",\"a\",\"anxiety-anti-diary\",{\"className\":\"link-unstyled\",\"href\":\"/categories/anxiety-anti-diary/\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"我的焦慮對抗日記\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",4,\")\"]}]]}]}],[\"$\",\"a\",\"life-experience\",{\"className\":\"link-unstyled\",\"href\":\"/categories/life-experience/\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"人生體驗與經驗\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",33,\")\"]}]]}]}],[\"$\",\"a\",\"thinking-and-reflection\",{\"className\":\"link-unstyled\",\"href\":\"/categories/thinking-and-reflection/\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"想東想西日常故事\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",5,\")\"]}]]}]}]]}]]}],[\"$\",\"div\",\"language-learning\",{\"children\":[[\"$\",\"a\",null,{\"href\":\"/categories/language-learning/\",\"className\":\"blog-link-style\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"語言相關 LANGUAGE\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",31,\")\"]}]]}]}],[\"$\",\"div\",null,{\"className\":\"list-disc list-inside ml-4 text-gray-600\",\"children\":[[\"$\",\"a\",\"experience-and-exam\",{\"className\":\"link-unstyled\",\"href\":\"/categories/experience-and-exam/\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"學習經驗與考試相關\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",14,\")\"]}]]}]}],[\"$\",\"a\",\"toefl-prepare-plan\",{\"className\":\"link-unstyled\",\"href\":\"/categories/toefl-prepare-plan/\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"托福準備紀錄\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",17,\")\"]}]]}]}]]}]]}],[\"$\",\"div\",\"travel-diary\",{\"children\":[[\"$\",\"a\",null,{\"href\":\"/categories/travel-diary/\",\"className\":\"blog-link-style\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"旅行日記 Travel\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",56,\")\"]}]]}]}],[\"$\",\"div\",null,{\"className\":\"list-disc list-inside ml-4 text-gray-600\",\"children\":[[\"$\",\"a\",\"japan\",{\"className\":\"link-unstyled\",\"href\":\"/categories/japan/\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"日本－自由行旅記\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",37,\")\"]}]]}]}],[\"$\",\"a\",\"taiwan\",{\"className\":\"link-unstyled\",\"href\":\"/categories/taiwan/\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"台灣－蕃薯故鄉走跳\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",5,\")\"]}]]}]}],[\"$\",\"a\",\"eu-europe\",{\"className\":\"link-unstyled\",\"href\":\"/categories/eu-europe/\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"歐洲－英國與冰島追逐幸福極光\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",3,\")\"]}]]}]}],[\"$\",\"a\",\"us-america\",{\"className\":\"link-unstyled\",\"href\":\"/categories/us-america/\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-3 text-sm border-b border-solid font-fondamento\",\"children\":[\"美國－賓州Juniata姐妹校與企業參訪\",\" \",[\"$\",\"span\",null,{\"className\":\"font-color-gold-1\",\"children\":[\"(\",11,\")\"]}]]}]}]]}]]}]],[\"$\",\"div\",null,{\"className\":\"mb-10 border border-solid py-4 mt-10\",\"children\":[\"$\",\"p\",null,{\"className\":\"font-bold text-center text-gray grid-subtitle text-md\",\"children\":\"GALLERY\"}]}]]}]}]]}]}]}]}]}],[\"$\",\"footer\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"bg-white border-t border-solid\",\"children\":[\"$\",\"div\",null,{\"className\":\"container px-5 mx-auto\",\"children\":[\"$\",\"div\",null,{\"className\":\"xl:w-1/2 lg:w-3/4 w-full mx-auto text-center\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-gray-600 text-center text-xl font-hand-writing tracking-wider py-8 px-2\",\"children\":\"Hi, It's Mina Yu, a software engineer, blogger and polyglot learner. Since 7-9 years ago, my dream is designing my own personal website and now I did it, I changed the website name to @Mina Influence, want to encourage people by my influence. I will continue to achieve more my dream in the future. I just want to tell you, no matter your plan looks how hard and how unachievable, Once you begin to do it, everything will be changed.\"}]}]}]}],[\"$\",\"div\",null,{\"className\":\"bg-cyan-50 border-t border-solid\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-gray-300 text-center text-md motto-block py-8 px-4\",\"children\":\"Copy Right © 2024 @Mina Influence. Designed by MINA YU. Sign @MinaYu.\"}]}]]}]]\n"])</script></body></html>